// Code generated by tygo. DO NOT EDIT.
import type { 
  LogLevel,
  Duration,
  ByteSize,
  ConnectorDriverType as TsConnectorDriverType,
  ConnectorConfig as TsConnectorConfig,
  UpstreamType as TsUpstreamType,
  NetworkArchitecture as TsNetworkArchitecture,
  AuthType as TsAuthType,
  AuthStrategyConfig as TsAuthStrategyConfig,
  EvmNetworkConfigForDefaults as TsEvmNetworkConfigForDefaults,
  SelectionPolicyEvalFunction
} from "./types"

//////////
// source: architecture_evm.go

export const UpstreamTypeEvm: UpstreamType = "evm";
export type EvmUpstream = 
    Upstream;
export type AvailbilityConfidence = number /* int */;
export const AvailbilityConfidenceBlockHead: AvailbilityConfidence = 1;
export const AvailbilityConfidenceFinalized: AvailbilityConfidence = 2;
export type EvmNodeType = string;
export const EvmNodeTypeUnknown: EvmNodeType = "unknown";
export const EvmNodeTypeFull: EvmNodeType = "full";
export const EvmNodeTypeArchive: EvmNodeType = "archive";
export type EvmSyncingState = number /* int */;
export const EvmSyncingStateUnknown: EvmSyncingState = 0;
export const EvmSyncingStateSyncing: EvmSyncingState = 1;
export const EvmSyncingStateNotSyncing: EvmSyncingState = 2;
export type EvmStatePoller = any;

//////////
// source: cache_dal.go

export type CacheDAL = any;

//////////
// source: cache_mock.go

export interface MockCacheDal {
  mock: any /* mock.Mock */;
}

//////////
// source: config.go

/**
 * Config represents the configuration of the application.
 */
export interface Config {
  logLevel?: LogLevel;
  clusterKey?: string;
  server?: ServerConfig;
  healthCheck?: HealthCheckConfig;
  admin?: AdminConfig;
  database?: DatabaseConfig;
  projects?: (ProjectConfig | undefined)[];
  rateLimiters?: RateLimiterConfig;
  metrics?: MetricsConfig;
  proxyPools?: (ProxyPoolConfig | undefined)[];
  tracing?: TracingConfig;
}
export interface ServerConfig {
  listenV4?: boolean;
  httpHostV4?: string;
  listenV6?: boolean;
  httpHostV6?: string;
  httpPort?: number /* int */; // Deprecated: use HttpPortV4
  httpPortV4?: number /* int */;
  httpPortV6?: number /* int */;
  maxTimeout?: Duration;
  readTimeout?: Duration;
  writeTimeout?: Duration;
  enableGzip?: boolean;
  tls?: TLSConfig;
  aliasing?: AliasingConfig;
  waitBeforeShutdown?: Duration;
  waitAfterShutdown?: Duration;
  includeErrorDetails?: boolean;
  trustedIPForwarders?: string[];
  trustedIPHeaders?: string[];
}
export interface HealthCheckConfig {
  mode?: HealthCheckMode;
  auth?: AuthConfig;
  defaultEval?: string;
}
export type HealthCheckMode = string;
export const HealthCheckModeSimple: HealthCheckMode = "simple";
export const HealthCheckModeNetworks: HealthCheckMode = "networks";
export const HealthCheckModeVerbose: HealthCheckMode = "verbose";
export const EvalAnyInitializedUpstreams = "any:initializedUpstreams";
export const EvalAnyErrorRateBelow90 = "any:errorRateBelow90";
export const EvalAllErrorRateBelow90 = "all:errorRateBelow90";
export const EvalAnyErrorRateBelow100 = "any:errorRateBelow100";
export const EvalAllErrorRateBelow100 = "all:errorRateBelow100";
export const EvalEvmAnyChainId = "any:evm:eth_chainId";
export const EvalEvmAllChainId = "all:evm:eth_chainId";
export const EvalAllActiveUpstreams = "all:activeUpstreams";
export type TracingProtocol = string;
export const TracingProtocolHttp: TracingProtocol = "http";
export const TracingProtocolGrpc: TracingProtocol = "grpc";
export interface TracingConfig {
  enabled?: boolean;
  endpoint?: string;
  protocol?: TracingProtocol;
  sampleRate?: number /* float64 */;
  detailed?: boolean;
  tls?: TLSConfig;
}
export interface AdminConfig {
  auth?: AuthConfig;
  cors?: CORSConfig;
}
export interface AliasingConfig {
  rules: (AliasingRuleConfig | undefined)[];
}
export interface AliasingRuleConfig {
  matchDomain: string;
  serveProject: string;
  serveArchitecture: string;
  serveChain: string;
}
export interface DatabaseConfig {
  evmJsonRpcCache?: CacheConfig;
  sharedState?: SharedStateConfig;
}
export interface SharedStateConfig {
  clusterKey?: string;
  connector?: ConnectorConfig;
  fallbackTimeout?: Duration;
  lockTtl?: Duration;
}
export interface CacheConfig {
  connectors?: TsConnectorConfig[];
  policies?: (CachePolicyConfig | undefined)[];
  compression?: CompressionConfig;
}
export interface CompressionConfig {
  enabled?: boolean;
  algorithm?: string; // "zstd" for now, can be extended
  zstdLevel?: string; // "fastest", "default", "better", "best"
  threshold?: number /* int */; // Minimum size in bytes to compress
}
export interface CacheMethodConfig {
  reqRefs: any[][];
  respRefs: any[][];
  finalized: boolean;
  realtime: boolean;
  stateful?: boolean;
}
export interface CachePolicyConfig {
  connector: string;
  network?: string;
  method?: string;
  params?: any[];
  finality?: DataFinalityState;
  empty?: CacheEmptyBehavior;
  appliesTo?: 'get' | 'set' | 'both';
  minItemSize?: ByteSize;
  maxItemSize?: ByteSize;
  ttl?: Duration;
}
export type ConnectorDriverType = string;
export const DriverMemory: ConnectorDriverType = "memory";
export const DriverRedis: ConnectorDriverType = "redis";
export const DriverPostgreSQL: ConnectorDriverType = "postgresql";
export const DriverDynamoDB: ConnectorDriverType = "dynamodb";
export const DriverGrpc: ConnectorDriverType = "grpc";
export interface ConnectorConfig {
  id?: string;
  driver: TsConnectorDriverType;
  memory?: MemoryConnectorConfig;
  redis?: RedisConnectorConfig;
  dynamodb?: DynamoDBConnectorConfig;
  postgresql?: PostgreSQLConnectorConfig;
  grpc?: GrpcConnectorConfig;
}
export interface GrpcConnectorConfig {
  bootstrap?: string;
  servers?: string[];
  headers?: { [key: string]: string};
}
export interface MemoryConnectorConfig {
  maxItems: number /* int */;
  maxTotalSize: string;
  emitMetrics?: boolean;
}
export interface MockConnectorConfig {
  memoryconnectorconfig: MemoryConnectorConfig;
  getdelay: number /* time in nanoseconds (time.Duration) */;
  setdelay: number /* time in nanoseconds (time.Duration) */;
  geterrorrate: number /* float64 */;
  seterrorrate: number /* float64 */;
}
export interface TLSConfig {
  enabled: boolean;
  certFile: string;
  keyFile: string;
  caFile?: string;
  insecureSkipVerify?: boolean;
}
export interface RedisConnectorConfig {
  addr?: string;
  username?: string;
  db?: number /* int */;
  tls?: TLSConfig;
  connPoolSize?: number /* int */;
  uri: string;
  initTimeout?: Duration;
  getTimeout?: Duration;
  setTimeout?: Duration;
  lockRetryInterval?: Duration;
}
export interface DynamoDBConnectorConfig {
  table?: string;
  region?: string;
  endpoint?: string;
  auth?: AwsAuthConfig;
  partitionKeyName?: string;
  rangeKeyName?: string;
  reverseIndexName?: string;
  ttlAttributeName?: string;
  initTimeout?: Duration;
  getTimeout?: Duration;
  setTimeout?: Duration;
  maxRetries?: number /* int */;
  statePollInterval?: Duration;
  lockRetryInterval?: Duration;
}
export interface PostgreSQLConnectorConfig {
  connectionUri: string;
  table: string;
  minConns?: number /* int32 */;
  maxConns?: number /* int32 */;
  initTimeout?: Duration;
  getTimeout?: Duration;
  setTimeout?: Duration;
}
export interface AwsAuthConfig {
  mode: 'file' | 'env' | 'secret'; // "file", "env", "secret"
  credentialsFile: string;
  profile: string;
  accessKeyID: string;
  secretAccessKey: string;
}
export interface ProjectConfig {
  id: string;
  auth?: AuthConfig;
  cors?: CORSConfig;
  providers?: (ProviderConfig | undefined)[];
  upstreamDefaults?: UpstreamConfig;
  upstreams?: (UpstreamConfig | undefined)[];
  networkDefaults?: NetworkDefaults;
  networks?: (NetworkConfig | undefined)[];
  rateLimitBudget?: string;
  scoreMetricsWindowSize?: Duration;
  scoreRefreshInterval?: Duration;
  healthCheck?: DeprecatedProjectHealthCheckConfig;
}
export interface NetworkDefaults {
  rateLimitBudget?: string;
  failsafe?: (FailsafeConfig | undefined)[];
  selectionPolicy?: SelectionPolicyConfig;
  directiveDefaults?: DirectiveDefaultsConfig;
  evm?: TsEvmNetworkConfigForDefaults;
}
export interface CORSConfig {
  allowedOrigins: string[];
  allowedMethods: string[];
  allowedHeaders: string[];
  exposedHeaders: string[];
  allowCredentials?: boolean;
  maxAge: number /* int */;
}
export type VendorSettings = { [key: string]: any};
export interface ProviderConfig {
  id?: string;
  vendor: string;
  settings?: VendorSettings;
  onlyNetworks?: string[];
  ignoreNetworks?: string[];
  upstreamIdTemplate?: string;
  overrides?: { [key: string]: UpstreamConfig | undefined};
}
export interface UpstreamConfig {
  id?: string;
  type?: TsUpstreamType;
  group?: string;
  vendorName?: string;
  endpoint?: string;
  evm?: EvmUpstreamConfig;
  jsonRpc?: JsonRpcUpstreamConfig;
  ignoreMethods?: string[];
  allowMethods?: string[];
  autoIgnoreUnsupportedMethods?: boolean;
  failsafe?: (FailsafeConfig | undefined)[];
  rateLimitBudget?: string;
  rateLimitAutoTune?: RateLimitAutoTuneConfig;
  routing?: RoutingConfig;
  shadow?: ShadowUpstreamConfig;
}
export interface ShadowUpstreamConfig {
  enabled: boolean;
  ignoreFields?: { [key: string]: string[]};
}
export interface UpstreamIntegrityConfig {
  eth_getBlockReceipts?: UpstreamIntegrityEthGetBlockReceiptsConfig;
}
export interface UpstreamIntegrityEthGetBlockReceiptsConfig {
  enabled?: boolean;
  checkLogIndexStrictIncrements?: boolean;
  checkLogsBloom?: boolean;
}
export interface RoutingConfig {
  scoreMultipliers: (ScoreMultiplierConfig | undefined)[];
  scoreLatencyQuantile?: number /* float64 */;
}
export interface ScoreMultiplierConfig {
  network: string;
  method: string;
  overall?: number /* float64 */;
  errorRate?: number /* float64 */;
  respLatency?: number /* float64 */;
  totalRequests?: number /* float64 */;
  throttledRate?: number /* float64 */;
  blockHeadLag?: number /* float64 */;
  finalizationLag?: number /* float64 */;
  misbehaviors?: number /* float64 */;
}
export type Alias = UpstreamConfig;
export interface RateLimitAutoTuneConfig {
  enabled?: boolean;
  adjustmentPeriod: Duration;
  errorRateThreshold: number /* float64 */;
  increaseFactor: number /* float64 */;
  decreaseFactor: number /* float64 */;
  minBudget: number /* int */;
  maxBudget: number /* int */;
}
export interface JsonRpcUpstreamConfig {
  supportsBatch?: boolean;
  batchMaxSize?: number /* int */;
  batchMaxWait?: Duration;
  enableGzip?: boolean;
  headers?: { [key: string]: string};
  proxyPool?: string;
}
export interface EvmUpstreamConfig {
  chainId: number /* int64 */;
  nodeType?: EvmNodeType;
  statePollerInterval?: Duration;
  statePollerDebounce?: Duration;
  maxAvailableRecentBlocks?: number /* int64 */;
  getLogsAutoSplittingRangeThreshold?: number /* int64 */;
  skipWhenSyncing?: boolean;
  integrity?: UpstreamIntegrityConfig;
}
export interface FailsafeConfig {
  matchMethod?: string;
  matchFinality?: DataFinalityState[];
  retry?: RetryPolicyConfig;
  circuitBreaker?: CircuitBreakerPolicyConfig;
  timeout?: TimeoutPolicyConfig;
  hedge?: HedgePolicyConfig;
  consensus?: ConsensusPolicyConfig;
}
export interface RetryPolicyConfig {
  maxAttempts: number /* int */;
  delay?: Duration;
  backoffMaxDelay?: Duration;
  backoffFactor?: number /* float32 */;
  jitter?: Duration;
  emptyResultConfidence?: AvailbilityConfidence;
  emptyResultIgnore?: string[];
  /**
   * EmptyResultMaxAttempts limits total attempts when retries are triggered due to empty responses.
   */
  emptyResultMaxAttempts?: number /* int */;
}
export interface CircuitBreakerPolicyConfig {
  failureThresholdCount: number /* uint */;
  failureThresholdCapacity: number /* uint */;
  halfOpenAfter?: Duration;
  successThresholdCount: number /* uint */;
  successThresholdCapacity: number /* uint */;
}
export interface TimeoutPolicyConfig {
  duration?: Duration;
}
export interface HedgePolicyConfig {
  delay?: Duration;
  maxCount: number /* int */;
  quantile?: number /* float64 */;
  minDelay?: Duration;
  maxDelay?: Duration;
}
export type ConsensusLowParticipantsBehavior = string;
export const ConsensusLowParticipantsBehaviorReturnError: ConsensusLowParticipantsBehavior = "returnError";
export const ConsensusLowParticipantsBehaviorAcceptMostCommonValidResult: ConsensusLowParticipantsBehavior = "acceptMostCommonValidResult";
export const ConsensusLowParticipantsBehaviorPreferBlockHeadLeader: ConsensusLowParticipantsBehavior = "preferBlockHeadLeader";
export const ConsensusLowParticipantsBehaviorOnlyBlockHeadLeader: ConsensusLowParticipantsBehavior = "onlyBlockHeadLeader";
export type ConsensusDisputeBehavior = string;
export const ConsensusDisputeBehaviorReturnError: ConsensusDisputeBehavior = "returnError";
export const ConsensusDisputeBehaviorAcceptMostCommonValidResult: ConsensusDisputeBehavior = "acceptMostCommonValidResult";
export const ConsensusDisputeBehaviorPreferBlockHeadLeader: ConsensusDisputeBehavior = "preferBlockHeadLeader";
export const ConsensusDisputeBehaviorOnlyBlockHeadLeader: ConsensusDisputeBehavior = "onlyBlockHeadLeader";
export interface ConsensusPolicyConfig {
  maxParticipants: number /* int */;
  agreementThreshold?: number /* int */;
  disputeBehavior?: ConsensusDisputeBehavior;
  lowParticipantsBehavior?: ConsensusLowParticipantsBehavior;
  punishMisbehavior?: PunishMisbehaviorConfig;
  disputeLogLevel?: string; // "trace", "debug", "info", "warn", "error"
  ignoreFields?: { [key: string]: string[]};
  preferNonEmpty?: boolean;
  preferLargerResponses?: boolean;
  misbehaviorsDestination?: MisbehaviorsDestinationConfig;
}
export type MisbehaviorsDestinationType = string;
export const MisbehaviorsDestinationTypeFile: MisbehaviorsDestinationType = "file";
export const MisbehaviorsDestinationTypeS3: MisbehaviorsDestinationType = "s3";
export interface MisbehaviorsDestinationConfig {
  /**
   * Type of destination: "file" or "s3"
   */
  type: 'file' | 's3';
  /**
   * Path for file destination, or S3 URI (s3://bucket/prefix/) for S3 destination
   */
  path: string;
  /**
   * Pattern for generating file names. Supports placeholders:
   * {dateByHour} - formatted as 2006-01-02-15
   * {dateByDay} - formatted as 2006-01-02
   * {method} - the RPC method name
   * {networkId} - the network ID with : replaced by _
   * {instanceId} - unique instance identifier
   */
  filePattern?: string;
  /**
   * S3-specific settings for bulk flushing
   */
  s3?: S3FlushConfig;
}
export interface S3FlushConfig {
  /**
   * Maximum number of records to buffer before flushing (default: 100)
   */
  maxRecords?: number /* int */;
  /**
   * Maximum size in bytes to buffer before flushing (default: 1MB)
   */
  maxSize?: number /* int64 */;
  /**
   * Maximum time to wait before flushing buffered records (default: 60s)
   */
  flushInterval?: Duration;
  /**
   * AWS region for S3 bucket (defaults to AWS_REGION env var)
   */
  region?: string;
  /**
   * AWS credentials config (optional). If not specified, uses standard AWS credential chain:
   * 1. Environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)
   * 2. IAM role (for EC2/ECS/EKS)
   * 3. Shared credentials file (~/.aws/credentials)
   * Supported modes: "env", "file", "secret"
   */
  credentials?: AwsAuthConfig;
  /**
   * Content type for uploaded files (default: "application/jsonl")
   */
  contentType?: string;
}
export interface PunishMisbehaviorConfig {
  disputeThreshold: number /* uint */;
  disputeWindow?: Duration;
  sitOutPenalty?: Duration;
}
export interface RateLimiterConfig {
  store?: RateLimitStoreConfig;
  budgets: RateLimitBudgetConfig[];
}
export interface RateLimitBudgetConfig {
  id: string;
  rules: RateLimitRuleConfig[];
}
export interface RateLimitRuleConfig {
  method: string;
  maxCount: number /* uint32 */;
  /**
   * Period is the canonical period selector. Supported: second, minute, hour, day, week, month, year
   */
  period: RateLimitPeriod;
  waitTime?: Duration;
  perIP?: boolean;
  perUser?: boolean;
  perNetwork?: boolean;
}
/**
 * RateLimitPeriod enumerates supported periods for rate limiting.
 * It is an int enum to enable strong typing in TypeScript generation, while
 * marshaling to JSON/YAML as human-readable strings like "second", "minute", etc.
 */
export type RateLimitPeriod = number /* int */;
export const RateLimitPeriodSecond: RateLimitPeriod = 0;
export const RateLimitPeriodMinute: RateLimitPeriod = 1;
export const RateLimitPeriodHour: RateLimitPeriod = 2;
export const RateLimitPeriodDay: RateLimitPeriod = 3;
export const RateLimitPeriodWeek: RateLimitPeriod = 4;
export const RateLimitPeriodMonth: RateLimitPeriod = 5;
export const RateLimitPeriodYear: RateLimitPeriod = 6;
export interface ProxyPoolConfig {
  id: string;
  urls: string[];
}
export interface DeprecatedProjectHealthCheckConfig {
  scoreMetricsWindowSize: Duration;
}
export interface MethodsConfig {
  preserveDefaultMethods?: boolean;
  definitions?: { [key: string]: CacheMethodConfig | undefined};
}
export interface NetworkConfig {
  architecture: TsNetworkArchitecture;
  rateLimitBudget?: string;
  failsafe?: (FailsafeConfig | undefined)[];
  evm?: EvmNetworkConfig;
  selectionPolicy?: SelectionPolicyConfig;
  directiveDefaults?: DirectiveDefaultsConfig;
  alias?: string;
  methods?: MethodsConfig;
}
export interface DirectiveDefaultsConfig {
  retryEmpty?: boolean;
  retryPending?: boolean;
  skipCacheRead?: boolean;
  useUpstream?: string;
}
export interface EvmNetworkConfig {
  chainId: number /* int64 */;
  fallbackFinalityDepth?: number /* int64 */;
  fallbackStatePollerDebounce?: Duration;
  integrity?: EvmIntegrityConfig;
  getLogsMaxAllowedRange?: number /* int64 */;
  getLogsMaxAllowedAddresses?: number /* int64 */;
  getLogsMaxAllowedTopics?: number /* int64 */;
  getLogsSplitOnError?: boolean;
  getLogsSplitConcurrency?: number /* int */;
}
export interface EvmIntegrityConfig {
  enforceHighestBlock?: boolean;
  enforceGetLogsBlockRange?: boolean;
  enforceNonNullTaggedBlocks?: boolean;
}
export interface SelectionPolicyConfig {
  evalInterval?: Duration;
  evalFunction?: SelectionPolicyEvalFunction | undefined;
  evalPerMethod?: boolean;
  resampleExcluded?: boolean;
  resampleInterval?: Duration;
  resampleCount?: number /* int */;
}
export type AuthType = string;
export const AuthTypeSecret: AuthType = "secret";
export const AuthTypeDatabase: AuthType = "database";
export const AuthTypeJwt: AuthType = "jwt";
export const AuthTypeSiwe: AuthType = "siwe";
export const AuthTypeNetwork: AuthType = "network";
export interface AuthConfig {
  strategies: TsAuthStrategyConfig[];
}
export interface AuthStrategyConfig {
  ignoreMethods?: string[];
  allowMethods?: string[];
  rateLimitBudget?: string;
  type: TsAuthType;
  network?: NetworkStrategyConfig;
  secret?: SecretStrategyConfig;
  database?: DatabaseStrategyConfig;
  jwt?: JwtStrategyConfig;
  siwe?: SiweStrategyConfig;
}
export interface SecretStrategyConfig {
  id: string;
  value: string;
  /**
   * RateLimitBudget, if set, is applied to the authenticated user from this strategy
   */
  rateLimitBudget?: string;
}
export interface DatabaseStrategyConfig {
  connector?: ConnectorConfig;
  cache?: DatabaseStrategyCacheConfig;
}
export interface DatabaseStrategyCacheConfig {
  ttl?: number /* time in nanoseconds (time.Duration) */;
  maxSize?: number /* int64 */;
  maxCost?: number /* int64 */;
  numCounters?: number /* int64 */;
}
export interface JwtStrategyConfig {
  allowedIssuers: string[];
  allowedAudiences: string[];
  allowedAlgorithms: string[];
  requiredClaims: string[];
  verificationKeys: { [key: string]: string};
  /**
   * RateLimitBudgetClaimName is the JWT claim name that, if present,
   * will be used to set the per-user RateLimitBudget override.
   * Defaults to "rlm".
   */
  rateLimitBudgetClaimName?: string;
}
export interface SiweStrategyConfig {
  allowedDomains: string[];
  /**
   * RateLimitBudget, if set, is applied to the authenticated user
   */
  rateLimitBudget?: string;
}
export interface NetworkStrategyConfig {
  allowedIPs: string[];
  allowedCIDRs: string[];
  allowLocalhost: boolean;
  trustedProxies: string[];
  /**
   * RateLimitBudget, if set, is applied to the authenticated user (client IP)
   */
  rateLimitBudget?: string;
}
export type LabelMode = string;
export const ErrorLabelModeVerbose: LabelMode = "verbose";
export const ErrorLabelModeCompact: LabelMode = "compact";
export interface MetricsConfig {
  enabled?: boolean;
  listenV4?: boolean;
  hostV4?: string;
  listenV6?: boolean;
  hostV6?: string;
  port?: number /* int */;
  errorLabelMode?: LabelMode;
  histogramBuckets?: string;
}
/**
 * RateLimitStoreConfig defines where rate limit counters are stored
 */
export interface RateLimitStoreConfig {
  driver: string; // "redis" | "memory"
  redis?: RedisConnectorConfig;
  cacheKeyPrefix?: string;
  nearLimitRatio?: number /* float32 */;
}

//////////
// source: data.go

export type DataFinalityState = number /* int */;
/**
 * Finalized gets 0 intentionally so that when user has not specified finality,
 * it defaults to finalized, which is safest sane default for caching.
 * This attribute will be calculated based on extracted block number (from request and/or response)
 * and comparing to the upstream (one that returned the response) 'finalized' block (fetch via evm state poller).
 */
export const DataFinalityStateFinalized: DataFinalityState = 0;
/**
 * When we CAN determine the block number, and it's after the upstream 'finalized' block, we consider the data unfinalized.
 */
export const DataFinalityStateUnfinalized: DataFinalityState = 1;
/**
 * Certain methods points are meant to be realtime and updated with every new block (e.g. eth_gasPrice).
 * These can be cached with short TTLs to improve performance.
 */
export const DataFinalityStateRealtime: DataFinalityState = 2;
/**
 * When we CANNOT determine the block number (e.g some trace by hash calls), we consider the data unknown.
 * Most often it is safe to cache this data for longer as they're access when block hash is provided directly.
 */
export const DataFinalityStateUnknown: DataFinalityState = 3;
export type CacheEmptyBehavior = number /* int */;
export const CacheEmptyBehaviorIgnore: CacheEmptyBehavior = 0;
export const CacheEmptyBehaviorAllow: CacheEmptyBehavior = 1;
export const CacheEmptyBehaviorOnly: CacheEmptyBehavior = 2;
/**
 * CachePolicyAppliesTo controls whether a cache policy applies to get, set, or both operations.
 */
export type CachePolicyAppliesTo = string;
export const CachePolicyAppliesToBoth: CachePolicyAppliesTo = "both";
export const CachePolicyAppliesToGet: CachePolicyAppliesTo = "get";
export const CachePolicyAppliesToSet: CachePolicyAppliesTo = "set";

//////////
// source: error_extractor.go

/**
 * JsonRpcErrorExtractor allows callers to inject architecture-specific
 * JSON-RPC error normalization logic into HTTP clients without creating
 * package import cycles.
 */
export type JsonRpcErrorExtractor = any;
/**
 * JsonRpcErrorExtractorFunc is an adapter to allow normal functions to be used
 * as JsonRpcErrorExtractor implementations.
 * Similar to http.HandlerFunc style adapters.
 */
export type JsonRpcErrorExtractorFunc = any;

//////////
// source: network.go

export type NetworkArchitecture = string;
export const ArchitectureEvm: NetworkArchitecture = "evm";
export type Network = any;
export type QuantileTracker = any;
export type TrackedMetrics = any;

//////////
// source: upstream.go

export type Scope = string;
/**
 * Policies must be created with a "network" in mind,
 * assuming there will be many upstreams e.g. Retry might endup using a different upstream
 */
export const ScopeNetwork: Scope = "network";
/**
 * Policies must be created with one only "upstream" in mind
 * e.g. Retry with be towards the same upstream
 */
export const ScopeUpstream: Scope = "upstream";
export type UpstreamType = string;
/**
 * HealthTracker is an interface for tracking upstream health metrics
 */
export type HealthTracker = any;
export type Upstream = any;

//////////
// source: user.go

export interface User {
  id: string;
  ratelimitbudget: string;
}
