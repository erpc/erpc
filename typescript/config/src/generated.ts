// Code generated by tygo. DO NOT EDIT.
import type { 
  LogLevel,
  Duration,
  ByteSize,
  ConnectorDriverType as TsConnectorDriverType,
  ConnectorConfig as TsConnectorConfig,
  UpstreamType as TsUpstreamType,
  NetworkArchitecture as TsNetworkArchitecture,
  AuthType as TsAuthType,
  AuthStrategyConfig as TsAuthStrategyConfig,
  EvmNetworkConfigForDefaults as TsEvmNetworkConfigForDefaults,
  SelectionPolicyEvalFunction
} from "./types"

//////////
// source: architecture_evm.go

export const UpstreamTypeEvm: UpstreamType = "evm";
export type EvmUpstream = 
    Upstream;
export type AvailbilityConfidence = number /* int */;
export const AvailbilityConfidenceBlockHead: AvailbilityConfidence = 1;
export const AvailbilityConfidenceFinalized: AvailbilityConfidence = 2;
export type EvmNodeType = string;
export const EvmNodeTypeUnknown: EvmNodeType = "unknown";
export const EvmNodeTypeFull: EvmNodeType = "full";
export const EvmNodeTypeArchive: EvmNodeType = "archive";
export type EvmSyncingState = number /* int */;
export const EvmSyncingStateUnknown: EvmSyncingState = 0;
export const EvmSyncingStateSyncing: EvmSyncingState = 1;
export const EvmSyncingStateNotSyncing: EvmSyncingState = 2;
export type EvmStatePoller = any;

//////////
// source: cache_dal.go

export type CacheDAL = any;

//////////
// source: cache_mock.go

export interface MockCacheDal {
  mock: any /* mock.Mock */;
}

//////////
// source: config.go

/**
 * Config represents the configuration of the application.
 */
export interface Config {
  logLevel?: LogLevel;
  clusterKey?: string;
  server?: ServerConfig;
  healthCheck?: HealthCheckConfig;
  admin?: AdminConfig;
  database?: DatabaseConfig;
  projects?: (ProjectConfig | undefined)[];
  rateLimiters?: RateLimiterConfig;
  metrics?: MetricsConfig;
  proxyPools?: (ProxyPoolConfig | undefined)[];
  tracing?: TracingConfig;
}
export interface ServerConfig {
  listenV4?: boolean;
  httpHostV4?: string;
  listenV6?: boolean;
  httpHostV6?: string;
  httpPort?: number /* int */;
  maxTimeout?: Duration;
  readTimeout?: Duration;
  writeTimeout?: Duration;
  enableGzip?: boolean;
  tls?: TLSConfig;
  aliasing?: AliasingConfig;
  waitBeforeShutdown?: Duration;
  waitAfterShutdown?: Duration;
  includeErrorDetails?: boolean;
}
export interface HealthCheckConfig {
  mode?: HealthCheckMode;
  auth?: AuthConfig;
  defaultEval?: string;
}
export type HealthCheckMode = string;
export const HealthCheckModeSimple: HealthCheckMode = "simple";
export const HealthCheckModeVerbose: HealthCheckMode = "verbose";
export const EvalAnyInitializedUpstreams = "any:initializedUpstreams";
export const EvalAnyErrorRateBelow90 = "any:errorRateBelow90";
export const EvalAllErrorRateBelow90 = "all:errorRateBelow90";
export const EvalAnyErrorRateBelow100 = "any:errorRateBelow100";
export const EvalAllErrorRateBelow100 = "all:errorRateBelow100";
export const EvalEvmAnyChainId = "any:evm:eth_chainId";
export const EvalEvmAllChainId = "all:evm:eth_chainId";
export const EvalAllActiveUpstreams = "all:activeUpstreams";
export type TracingProtocol = string;
export const TracingProtocolHttp: TracingProtocol = "http";
export const TracingProtocolGrpc: TracingProtocol = "grpc";
export interface TracingConfig {
  enabled?: boolean;
  endpoint?: string;
  protocol?: TracingProtocol;
  sampleRate?: number /* float64 */;
  detailed?: boolean;
  tls?: TLSConfig;
}
export interface AdminConfig {
  auth?: AuthConfig;
  cors?: CORSConfig;
}
export interface AliasingConfig {
  rules: (AliasingRuleConfig | undefined)[];
}
export interface AliasingRuleConfig {
  matchDomain: string;
  serveProject: string;
  serveArchitecture: string;
  serveChain: string;
}
export interface DatabaseConfig {
  evmJsonRpcCache?: CacheConfig;
  sharedState?: SharedStateConfig;
}
export interface SharedStateConfig {
  clusterKey?: string;
  connector?: ConnectorConfig;
  fallbackTimeout?: Duration;
  lockTtl?: Duration;
}
export interface CacheConfig {
  connectors?: TsConnectorConfig[];
  policies?: (CachePolicyConfig | undefined)[];
  compression?: CompressionConfig;
}
export interface CompressionConfig {
  enabled?: boolean;
  algorithm?: string; // "zstd" for now, can be extended
  zstdLevel?: string; // "fastest", "default", "better", "best"
  threshold?: number /* int */; // Minimum size in bytes to compress
}
export interface CacheMethodConfig {
  reqRefs: any[][];
  respRefs: any[][];
  finalized: boolean;
  realtime: boolean;
}
export interface CachePolicyConfig {
  connector: string;
  network?: string;
  method?: string;
  params?: any[];
  finality?: DataFinalityState;
  empty?: CacheEmptyBehavior;
  minItemSize?: ByteSize;
  maxItemSize?: ByteSize;
  ttl?: Duration;
}
export type ConnectorDriverType = string;
export const DriverMemory: ConnectorDriverType = "memory";
export const DriverRedis: ConnectorDriverType = "redis";
export const DriverPostgreSQL: ConnectorDriverType = "postgresql";
export const DriverDynamoDB: ConnectorDriverType = "dynamodb";
export interface ConnectorConfig {
  id?: string;
  driver: TsConnectorDriverType;
  memory?: MemoryConnectorConfig;
  redis?: RedisConnectorConfig;
  dynamodb?: DynamoDBConnectorConfig;
  postgresql?: PostgreSQLConnectorConfig;
}
export interface MemoryConnectorConfig {
  maxItems: number /* int */;
  maxTotalSize: string;
  emitMetrics?: boolean;
}
export interface MockConnectorConfig {
  memoryconnectorconfig: MemoryConnectorConfig;
  getdelay: number /* time in nanoseconds (time.Duration) */;
  setdelay: number /* time in nanoseconds (time.Duration) */;
  geterrorrate: number /* float64 */;
  seterrorrate: number /* float64 */;
}
export interface TLSConfig {
  enabled: boolean;
  certFile: string;
  keyFile: string;
  caFile?: string;
  insecureSkipVerify?: boolean;
}
export interface RedisConnectorConfig {
  addr?: string;
  username?: string;
  db?: number /* int */;
  tls?: TLSConfig;
  connPoolSize?: number /* int */;
  uri: string;
  initTimeout?: Duration;
  getTimeout?: Duration;
  setTimeout?: Duration;
  lockRetryInterval?: Duration;
}
export interface DynamoDBConnectorConfig {
  table?: string;
  region?: string;
  endpoint?: string;
  auth?: AwsAuthConfig;
  partitionKeyName?: string;
  rangeKeyName?: string;
  reverseIndexName?: string;
  ttlAttributeName?: string;
  initTimeout?: Duration;
  getTimeout?: Duration;
  setTimeout?: Duration;
  maxRetries?: number /* int */;
  statePollInterval?: Duration;
  lockRetryInterval?: Duration;
}
export interface PostgreSQLConnectorConfig {
  connectionUri: string;
  table: string;
  minConns?: number /* int32 */;
  maxConns?: number /* int32 */;
  initTimeout?: Duration;
  getTimeout?: Duration;
  setTimeout?: Duration;
}
export interface AwsAuthConfig {
  mode: 'file' | 'env' | 'secret'; // "file", "env", "secret"
  credentialsFile: string;
  profile: string;
  accessKeyID: string;
  secretAccessKey: string;
}
export interface ProjectConfig {
  id: string;
  auth?: AuthConfig;
  cors?: CORSConfig;
  providers?: (ProviderConfig | undefined)[];
  upstreamDefaults?: UpstreamConfig;
  upstreams?: (UpstreamConfig | undefined)[];
  networkDefaults?: NetworkDefaults;
  networks?: (NetworkConfig | undefined)[];
  rateLimitBudget?: string;
  scoreMetricsWindowSize?: Duration;
  healthCheck?: DeprecatedProjectHealthCheckConfig;
}
export interface NetworkDefaults {
  rateLimitBudget?: string;
  failsafe?: (FailsafeConfig | undefined)[];
  selectionPolicy?: SelectionPolicyConfig;
  directiveDefaults?: DirectiveDefaultsConfig;
  evm?: TsEvmNetworkConfigForDefaults;
}
/**
 * Define a type alias to avoid recursion
 */
/**
 * If that fails, try the old format with single failsafe object
 */
export interface CORSConfig {
  allowedOrigins: string[];
  allowedMethods: string[];
  allowedHeaders: string[];
  exposedHeaders: string[];
  allowCredentials?: boolean;
  maxAge: number /* int */;
}
export type VendorSettings = { [key: string]: any};
export interface ProviderConfig {
  id?: string;
  vendor: string;
  settings?: VendorSettings;
  onlyNetworks?: string[];
  ignoreNetworks?: string[];
  upstreamIdTemplate?: string;
  overrides?: { [key: string]: UpstreamConfig | undefined};
}
export interface UpstreamConfig {
  id?: string;
  type?: TsUpstreamType;
  group?: string;
  vendorName?: string;
  endpoint?: string;
  evm?: EvmUpstreamConfig;
  jsonRpc?: JsonRpcUpstreamConfig;
  ignoreMethods?: string[];
  allowMethods?: string[];
  autoIgnoreUnsupportedMethods?: boolean;
  failsafe?: (FailsafeConfig | undefined)[];
  rateLimitBudget?: string;
  rateLimitAutoTune?: RateLimitAutoTuneConfig;
  routing?: RoutingConfig;
  shadow?: ShadowUpstreamConfig;
}
/**
 * Define a type alias to avoid recursion
 */
/**
 * If that fails, try the old format with single failsafe object
 */
export interface ShadowUpstreamConfig {
  enabled: boolean;
  ignoreFields?: { [key: string]: string[]};
}
export interface RoutingConfig {
  scoreMultipliers: (ScoreMultiplierConfig | undefined)[];
  scoreLatencyQuantile?: number /* float64 */;
}
export interface ScoreMultiplierConfig {
  network: string;
  method: string;
  overall?: number /* float64 */;
  errorRate?: number /* float64 */;
  respLatency?: number /* float64 */;
  totalRequests?: number /* float64 */;
  throttledRate?: number /* float64 */;
  blockHeadLag?: number /* float64 */;
  finalizationLag?: number /* float64 */;
}
export type Alias = UpstreamConfig;
export interface RateLimitAutoTuneConfig {
  enabled?: boolean;
  adjustmentPeriod: Duration;
  errorRateThreshold: number /* float64 */;
  increaseFactor: number /* float64 */;
  decreaseFactor: number /* float64 */;
  minBudget: number /* int */;
  maxBudget: number /* int */;
}
export interface JsonRpcUpstreamConfig {
  supportsBatch?: boolean;
  batchMaxSize?: number /* int */;
  batchMaxWait?: Duration;
  enableGzip?: boolean;
  headers?: { [key: string]: string};
  proxyPool?: string;
}
export interface EvmUpstreamConfig {
  chainId: number /* int64 */;
  nodeType?: EvmNodeType;
  statePollerInterval?: Duration;
  statePollerDebounce?: Duration;
  maxAvailableRecentBlocks?: number /* int64 */;
  getLogsAutoSplittingRangeThreshold?: number /* int64 */;
  getLogsMaxAllowedRange?: number /* int64 */;
  getLogsMaxAllowedAddresses?: number /* int64 */;
  getLogsMaxAllowedTopics?: number /* int64 */;
  getLogsSplitOnError?: boolean;
  skipWhenSyncing?: boolean;
}
export interface FailsafeConfig {
  matchMethod?: string;
  matchFinality?: DataFinalityState[];
  retry?: RetryPolicyConfig;
  circuitBreaker?: CircuitBreakerPolicyConfig;
  timeout?: TimeoutPolicyConfig;
  hedge?: HedgePolicyConfig;
  consensus?: ConsensusPolicyConfig;
}
export interface RetryPolicyConfig {
  maxAttempts: number /* int */;
  delay?: Duration;
  backoffMaxDelay?: Duration;
  backoffFactor?: number /* float32 */;
  jitter?: Duration;
  emptyResultConfidence?: AvailbilityConfidence;
  emptyResultIgnore?: string[];
}
export interface CircuitBreakerPolicyConfig {
  failureThresholdCount: number /* uint */;
  failureThresholdCapacity: number /* uint */;
  halfOpenAfter?: Duration;
  successThresholdCount: number /* uint */;
  successThresholdCapacity: number /* uint */;
}
export interface TimeoutPolicyConfig {
  duration?: Duration;
}
export interface HedgePolicyConfig {
  delay?: Duration;
  maxCount: number /* int */;
  quantile?: number /* float64 */;
  minDelay?: Duration;
  maxDelay?: Duration;
}
export type ConsensusLowParticipantsBehavior = string;
export const ConsensusLowParticipantsBehaviorReturnError: ConsensusLowParticipantsBehavior = "returnError";
export const ConsensusLowParticipantsBehaviorAcceptMostCommonValidResult: ConsensusLowParticipantsBehavior = "acceptMostCommonValidResult";
export const ConsensusLowParticipantsBehaviorPreferBlockHeadLeader: ConsensusLowParticipantsBehavior = "preferBlockHeadLeader";
export const ConsensusLowParticipantsBehaviorOnlyBlockHeadLeader: ConsensusLowParticipantsBehavior = "onlyBlockHeadLeader";
export type ConsensusDisputeBehavior = string;
export const ConsensusDisputeBehaviorReturnError: ConsensusDisputeBehavior = "returnError";
export const ConsensusDisputeBehaviorAcceptMostCommonValidResult: ConsensusDisputeBehavior = "acceptMostCommonValidResult";
export const ConsensusDisputeBehaviorPreferBlockHeadLeader: ConsensusDisputeBehavior = "preferBlockHeadLeader";
export const ConsensusDisputeBehaviorOnlyBlockHeadLeader: ConsensusDisputeBehavior = "onlyBlockHeadLeader";
export interface ConsensusPolicyConfig {
  requiredParticipants: number /* int */;
  agreementThreshold?: number /* int */;
  disputeBehavior?: ConsensusDisputeBehavior;
  lowParticipantsBehavior?: ConsensusLowParticipantsBehavior;
  punishMisbehavior?: PunishMisbehaviorConfig;
  disputeLogLevel?: string; // "trace", "debug", "info", "warn", "error"
  ignoreFields?: { [key: string]: string[]};
}
export interface PunishMisbehaviorConfig {
  disputeThreshold: number /* uint */;
  disputeWindow?: Duration;
  sitOutPenalty?: Duration;
}
export interface RateLimiterConfig {
  budgets: RateLimitBudgetConfig[];
}
export interface RateLimitBudgetConfig {
  id: string;
  rules: RateLimitRuleConfig[];
}
export interface RateLimitRuleConfig {
  method: string;
  maxCount: number /* uint */;
  period: Duration;
  waitTime: Duration;
}
export interface ProxyPoolConfig {
  id: string;
  urls: string[];
}
export interface DeprecatedProjectHealthCheckConfig {
  scoreMetricsWindowSize: Duration;
}
export interface MethodsConfig {
  preserveDefaultMethods?: boolean;
  definitions?: { [key: string]: CacheMethodConfig | undefined};
}
export interface NetworkConfig {
  architecture: TsNetworkArchitecture;
  rateLimitBudget?: string;
  failsafe?: (FailsafeConfig | undefined)[];
  evm?: EvmNetworkConfig;
  selectionPolicy?: SelectionPolicyConfig;
  directiveDefaults?: DirectiveDefaultsConfig;
  alias?: string;
  methods?: MethodsConfig;
}
/**
 * Define a type alias to avoid recursion
 */
/**
 * If that fails, try the old format with single failsafe object
 */
export interface DirectiveDefaultsConfig {
  retryEmpty?: boolean;
  retryPending?: boolean;
  skipCacheRead?: boolean;
  useUpstream?: string;
}
export interface EvmNetworkConfig {
  chainId: number /* int64 */;
  fallbackFinalityDepth?: number /* int64 */;
  fallbackStatePollerDebounce?: Duration;
  integrity?: EvmIntegrityConfig;
}
export interface EvmIntegrityConfig {
  enforceHighestBlock?: boolean;
  enforceGetLogsBlockRange?: boolean;
}
export interface SelectionPolicyConfig {
  evalInterval?: Duration;
  evalFunction?: SelectionPolicyEvalFunction | undefined;
  evalPerMethod?: boolean;
  resampleExcluded?: boolean;
  resampleInterval?: Duration;
  resampleCount?: number /* int */;
}
export type AuthType = string;
export const AuthTypeSecret: AuthType = "secret";
export const AuthTypeJwt: AuthType = "jwt";
export const AuthTypeSiwe: AuthType = "siwe";
export const AuthTypeNetwork: AuthType = "network";
export interface AuthConfig {
  strategies: TsAuthStrategyConfig[];
}
export interface AuthStrategyConfig {
  ignoreMethods?: string[];
  allowMethods?: string[];
  rateLimitBudget?: string;
  type: TsAuthType;
  network?: NetworkStrategyConfig;
  secret?: SecretStrategyConfig;
  jwt?: JwtStrategyConfig;
  siwe?: SiweStrategyConfig;
}
export interface SecretStrategyConfig {
  value: string;
}
export interface JwtStrategyConfig {
  allowedIssuers: string[];
  allowedAudiences: string[];
  allowedAlgorithms: string[];
  requiredClaims: string[];
  verificationKeys: { [key: string]: string};
}
export interface SiweStrategyConfig {
  allowedDomains: string[];
}
export interface NetworkStrategyConfig {
  allowedIPs: string[];
  allowedCIDRs: string[];
  allowLocalhost: boolean;
  trustedProxies: string[];
}
export type LabelMode = string;
export const ErrorLabelModeVerbose: LabelMode = "verbose";
export const ErrorLabelModeCompact: LabelMode = "compact";
export interface MetricsConfig {
  enabled?: boolean;
  listenV4?: boolean;
  hostV4?: string;
  listenV6?: boolean;
  hostV6?: string;
  port?: number /* int */;
  errorLabelMode?: LabelMode;
  histogramBuckets?: string;
}

//////////
// source: data.go

export type DataFinalityState = number /* int */;
/**
 * Finalized gets 0 intentionally so that when user has not specified finality,
 * it defaults to finalized, which is safest sane default for caching.
 * This attribute will be calculated based on extracted block number (from request and/or response)
 * and comparing to the upstream (one that returned the response) 'finalized' block (fetch via evm state poller).
 */
export const DataFinalityStateFinalized: DataFinalityState = 0;
/**
 * When we CAN determine the block number, and it's after the upstream 'finalized' block, we consider the data unfinalized.
 */
export const DataFinalityStateUnfinalized: DataFinalityState = 1;
/**
 * Certain methods points are meant to be realtime and updated with every new block (e.g. eth_gasPrice).
 * These can be cached with short TTLs to improve performance.
 */
export const DataFinalityStateRealtime: DataFinalityState = 2;
/**
 * When we CANNOT determine the block number (e.g some trace by hash calls), we consider the data unknown.
 * Most often it is safe to cache this data for longer as they're access when block hash is provided directly.
 */
export const DataFinalityStateUnknown: DataFinalityState = 3;
export type CacheEmptyBehavior = number /* int */;
export const CacheEmptyBehaviorIgnore: CacheEmptyBehavior = 0;
export const CacheEmptyBehaviorAllow: CacheEmptyBehavior = 1;
export const CacheEmptyBehaviorOnly: CacheEmptyBehavior = 2;

//////////
// source: network.go

export type NetworkArchitecture = string;
export const ArchitectureEvm: NetworkArchitecture = "evm";
export type Network = any;
export type QuantileTracker = any;
export type TrackedMetrics = any;

//////////
// source: upstream.go

export type Scope = string;
/**
 * Policies must be created with a "network" in mind,
 * assuming there will be many upstreams e.g. Retry might endup using a different upstream
 */
export const ScopeNetwork: Scope = "network";
/**
 * Policies must be created with one only "upstream" in mind
 * e.g. Retry with be towards the same upstream
 */
export const ScopeUpstream: Scope = "upstream";
export type UpstreamType = string;
export type Upstream = any;
