---
description: Failsafe policies are defined on network/upstream level to help with intermittent issues and increase general resiliency...
---

import { Callout, Tabs, Tab } from "nextra/components";

# Failsafe

Failsafe policies help with intermittent issues and increase resiliency. They can be configured at both [Network](/config/projects/networks) and [Upstream](/config/projects/upstreams) levels, with support for **per-method** configuration.

## Available policies

- [`timeout:`](/config/failsafe#timeout-policy) prevents requests from hanging indefinitely
- [`retry:`](/config/failsafe#retry-policy) recovers from transient failures
- [`hedge:`](/config/failsafe#hedge-policy) runs parallel requests when upstreams are slow
- [`circuitBreaker:`](/config/failsafe#circuitbreaker-policy) temporarily removes failing upstreams
- [`consensus:`](/config/failsafe/consensus) verifies multiple upstreams agree on results
- [Integrity](/config/failsafe/integrity) increases data quality for specific methods

## Per-method configuration

Failsafe policies can be configured per-method using matcher objects for fine-grained control. All of the matchers support [matcher syntax](/config/matcher).

- `matchers`: Array of matcher objects with the following fields:
  - `method`: Pattern to match RPC methods (optional), defaults to `*` (all methods)
  - `network`: Pattern to match network identifiers (optional), defaults to `*` (all networks)
  - `params`: Array of parameter values to match (optional), defaults to `*` (all parameters)
  - `finality`: Array of finality states to match (optional), defaults to `*` (all finality states)
  - `action`: `include` or `exclude` (optional, default: `include`)

When multiple failsafe configs are defined, they are evaluated in order and the first matching config is used.

### Finality States

The `finality` field in matcher objects can match against these data finality states:

- **`finalized`**: Data from blocks that are confirmed as finalized and safe from reorgs. This is determined by comparing the block number with the upstream's finalized block.
  - Example methods: `eth_getBlockByNumber` (for old blocks), `eth_getLogs` (for finalized ranges)
  - Use case: Can have relaxed failsafe policies since data won't change

- **`unfinalized`**: Data from recent blocks that could still be reorganized. Also includes any data from pending blocks.
  - Example methods: `eth_getBlockByNumber("latest")`, `eth_call` with recent blocks
  - Use case: May need more aggressive retries and shorter timeouts

- **`realtime`**: Data that changes frequently, typically with every new block.
  - Example methods: `eth_blockNumber`, `eth_gasPrice`, `eth_maxPriorityFeePerGas`, `net_peerCount`
  - Use case: Often needs fast timeouts and may benefit from hedging

- **`unknown`**: When the block number cannot be determined from the request/response.
  - Example methods: `eth_getTransactionByHash`, `trace_transaction`, `debug_traceTransaction`
  - Use case: Data is typically immutable once included, but block context is unknown

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: main
    upstreams:
      - id: my-upstream
        failsafe:
          # Default policy for all methods
          - matchers:
              - method: "*"
                action: include
            timeout:
              duration: 30s
            retry:
              maxAttempts: 3
          
          # Fast timeout for simple queries
          - matchers:
              - method: "eth_getBlock*|eth_getTransaction*"
                action: include
            timeout:
              duration: 5s
            retry:
              maxAttempts: 2
              delay: 100ms
          
          # Longer timeout for heavy trace methods
          - matchers:
              - method: "trace_*|debug_*"
                action: include
            timeout:
              duration: 60s
            retry:
              maxAttempts: 1    # expensive operations, minimize retries
          
          # Different policy for finalized vs unfinalized data
          - matchers:
              - method: "eth_call|eth_estimateGas"
                finality: ["unfinalized", "realtime"]
                action: include
            timeout:
              duration: 10s
            retry:
              maxAttempts: 5    # unfinalized data changes frequently, retry more
          
          # Apply aggressive policies only to specific networks and methods
          - matchers:
              - network: "evm:1"          # Ethereum mainnet
                method: "eth_getLogs"
                finality: ["finalized"]
                action: include
              - network: "evm:137"        # Polygon
                method: "trace_*"
                action: include
            timeout:
              duration: 45s
            retry:
              maxAttempts: 2
          
          # Exclude certain methods from retry policies
          - matchers:
              - method: "*"
                action: include
              - method: "debug_traceTransaction"  # expensive, don't retry
                action: exclude
            retry:
              maxAttempts: 3
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "main",
    upstreams: [{
      id: "my-upstream",
      failsafe: [
        // Default policy for all methods
        {
          matchers: [
            {
              method: "*",
              action: "include"
            }
          ],
          timeout: { duration: "30s" },
          retry: { maxAttempts: 3 }
        },
        // Fast timeout for simple queries
        {
          matchers: [
            {
              method: "eth_getBlock*|eth_getTransaction*",
              action: "include"
            }
          ],
          timeout: { duration: "5s" },
          retry: { maxAttempts: 2, delay: "100ms" }
        },
        // Longer timeout for heavy trace methods
        {
          matchers: [
            {
              method: "trace_*|debug_*",
              action: "include"
            }
          ],
          timeout: { duration: "60s" },
          retry: { maxAttempts: 1 }    // expensive operations, minimize retries
        },
        // Different policy for finalized vs unfinalized data
        {
          matchers: [
            {
              method: "eth_call|eth_estimateGas",
              finality: ["unfinalized", "realtime"],
              action: "include"
            }
          ],
          timeout: { duration: "10s" },
          retry: { maxAttempts: 5 }    // unfinalized data changes frequently, retry more
        },
        // Apply aggressive policies only to specific networks and methods
        {
          matchers: [
            {
              network: "evm:1",          // Ethereum mainnet
              method: "eth_getLogs",
              finality: ["finalized"],
              action: "include"
            },
            {
              network: "evm:137",        // Polygon
              method: "trace_*",
              action: "include"
            }
          ],
          timeout: { duration: "45s" },
          retry: { maxAttempts: 2 }
        },
        // Exclude certain methods from retry policies
        {
          matchers: [
            {
              method: "*",
              action: "include"
            },
            {
              method: "debug_traceTransaction",  // expensive, don't retry
              action: "exclude"
            }
          ],
          retry: { maxAttempts: 3 }
        }
      ]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

## `timeout` policy

Sets a timeout for requests. Network-level timeout applies to the entire request lifecycle (including retries), while upstream-level timeout applies to each individual attempt.

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: main
    networks:
      - architecture: evm
        evm:
          chainId: 42161
        failsafe:
          - matchers:
              - method: "*"
                action: include
            timeout:
              duration: 30s        # Total time including all retries
    
    upstreams:
      - id: blastapi-chain-42161
        failsafe:
          - matchers:
              - method: "*"
                action: include
            timeout:
              duration: 15s        # Per-attempt timeout
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "main",
    networks: [{
      architecture: "evm",
      evm: { chainId: 42161 },
      failsafe: [{
        matchers: [{
          method: "*",
          action: "include"
        }],
        timeout: { duration: "30s" }    // Total time including all retries
      }]
    }],
    upstreams: [{
      id: "blastapi-chain-42161",
      failsafe: [{
        matchers: [{
          method: "*",
          action: "include"
        }],
        timeout: { duration: "15s" }    // Per-attempt timeout
      }]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

## `retry` policy

Automatically retries failed requests with configurable backoff strategies.

#### Retryable Errors
- `5xx` server errors (intermittent issues)
- `408` request timeout
- `429` rate limit exceeded
- Empty responses for certain methods (e.g., `eth_getLogs` when node is lagging)

#### Non-Retryable Errors
- `4xx` client errors (invalid requests)
- Unsupported method errors

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: main
    upstreams:
      - id: my-upstream
        failsafe:
          - matchers:
              - method: "*"
                action: include
            retry:
              maxAttempts: 3        # Total attempts (initial + 2 retries)
              delay: 1000ms         # Initial delay between retries
              backoffMaxDelay: 10s  # Maximum delay after backoff
              backoffFactor: 0.3    # Exponential backoff multiplier
              jitter: 500ms         # Random jitter (0-500ms) to prevent thundering herd
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "main",
    upstreams: [{
      id: "my-upstream",
      failsafe: [{
        matchers:
              - method: "*"
                action: include,
        retry: {
          maxAttempts: 3,        // Total attempts (initial + 2 retries)
          delay: "1000ms",       // Initial delay between retries
          backoffMaxDelay: "10s", // Maximum delay after backoff
          backoffFactor: 0.3,    // Exponential backoff multiplier
          jitter: "500ms"        // Random jitter (0-500ms) to prevent thundering herd
        }
      }]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

### Empty responses

Retry feature is useful to handle empty responses when a node is lagging behind or for some other reason returns an unexpected empty response.

- **What counts as empty**: Results like `null`, `[]`, `""`, `{}`, `0x`, `"0x"`, hex strings that are all zeros (e.g., `0x000...0`), and method-specific empties (e.g., empty logs). Internally we detect these directly from response bytes.
- **Where retries apply**: Only at the **network level** when the request has `retryEmpty` enabled (via directive defaults or request headers/params). Upstream-level retry does not retry on empties.
- **Default ignore list (`retry.emptyResultIgnore`)**: Methods to NEVER retry when the response is empty (e.g., `eth_getLogs`, `eth_call`). Configure to override defaults.
- **Block availability check**: For EVM, when empty and the upstream is not syncing, we try to extract the block number and check upstream availability. If the upstream can serve that block but still returned empty, we do not retry.
- **Availability confidence (`retry.emptyResultConfidence`)**:
  - `finalizedBlock`: If the target block is finalized (at or below finalized), empty responses are treated as valid (no retry). If the target block is after finalized, we will retry.
  - `blockHead`: If the target block is at or below the node's latest head, empty responses are treated as valid (no retry). If the target block is ahead of the head, we will retry.
- **Syncing nodes**: If an upstream is syncing and returns empty, it is treated unfavorably and skipped for the remainder of the request.
- **Per-request de-dup**: Upstreams that returned empty for a request are skipped on subsequent rotations for that same request.
- **Cap empty retries**: `retry.emptyResultMaxAttempts` caps total attempts specifically for empty-result retries (default equals `retry.maxAttempts`).
- **Non-empty wins**: If any non-empty response was seen, it is preserved and can be returned even if later attempts fail. In consensus, when configured, non-empty results are preferred.
- **Writes are never retried**: Write methods (e.g., `eth_send*`) are not retried.

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="EmptyRetryConfigTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: main
    networks:
      - architecture: evm
        evm:
          chainId: 1
        directiveDefaults:
          retryEmpty: true # enable empty-result retries at network level
        failsafe:
          - matchMethod: "*"
            retry:
              maxAttempts: 4 # total attempts (initial + retries)
              emptyResultIgnore: ["eth_getLogs", "eth_call"] # Never retry these methods when result is empty
              emptyResultConfidence: finalizedBlock # treat finalized empties as valid
              emptyResultMaxAttempts: 2 # cap attempts for empty-result retries only
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "main",
    networks: [{
      architecture: "evm",
      evm: { chainId: 1 },
      directiveDefaults: {
        retryEmpty: true                // enable empty-result retries at network level
      },
      failsafe: [{
        matchMethod: "*",
        retry: {
          maxAttempts: 4,
          // emptyResultIgnore: ["eth_getLogs", "eth_call"], // NEVER retry these when empty
          // emptyResultConfidence: "finalized",              // treat finalized empties as valid
          emptyResultMaxAttempts: 2      // cap attempts for empty-result retries only
        }
      }]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

## `hedge` policy

Starts parallel requests when an upstream is slow to respond. Highly recommended at network level for optimal performance.

<Callout type="info">
  **Quantile-based hedging** (recommended) uses response time statistics to determine optimal hedge timing, while **fixed-delay hedging** uses a static delay.
</Callout>

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: main
    networks:
      - architecture: evm
        evm:
          chainId: 1
        failsafe:
          - matchers:
              - method: "*"
                action: include
            hedge:
              # Quantile-based (recommended): hedge after p99 response time
              quantile: 0.99
              minDelay: 100ms     # Minimum wait before hedging
              maxDelay: 2s        # Maximum wait before hedging
              maxCount: 1         # Max parallel hedged requests
              
              # Alternative: Fixed-delay hedging
              # delay: 500ms
              # maxCount: 1
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "main",
    networks: [{
      architecture: "evm",
      evm: { chainId: 1 },
      failsafe: [{
        matchers:
              - method: "*"
                action: include,
        hedge: {
          // Quantile-based (recommended): hedge after p99 response time
          quantile: 0.99,
          minDelay: "100ms",     // Minimum wait before hedging
          maxDelay: "2s",        // Maximum wait before hedging
          maxCount: 1            // Max parallel hedged requests
          
          // Alternative: Fixed-delay hedging
          // delay: "500ms",
          // maxCount: 1
        }
      }]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

Monitor effectiveness via Prometheus metrics:
- `erpc_network_hedged_request_total` - total hedged requests
- `erpc_network_hedge_discards_total` - wasted hedges (original responded first)

## `circuitBreaker` policy

Temporarily removes consistently failing upstreams to allow recovery time.

<Callout type="info">
  Circuit breaker states:
  - **Closed**: Normal operation, upstream is healthy
  - **Open**: Upstream is failing, temporarily removed from rotation
  - **Half-open**: Testing if upstream has recovered with limited traffic
</Callout>

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: main
    upstreams:
      - id: my-upstream
        failsafe:
          - matchers:
              - method: "*"
                action: include
            circuitBreaker:
              # Open circuit when 80% (160/200) of recent requests fail
              failureThresholdCount: 160
              failureThresholdCapacity: 200
              halfOpenAfter: 60s          # Try recovery after 1 minute
              # Close circuit when 80% (8/10) succeed in half-open state
              successThresholdCount: 8
              successThresholdCapacity: 10
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "main",
    upstreams: [{
      id: "my-upstream",
      failsafe: [{
        matchers:
              - method: "*"
                action: include,
        circuitBreaker: {
          // Open circuit when 80% (160/200) of recent requests fail
          failureThresholdCount: 160,
          failureThresholdCapacity: 200,
          halfOpenAfter: "60s",          // Try recovery after 1 minute
          // Close circuit when 80% (8/10) succeed in half-open state
          successThresholdCount: 8,
          successThresholdCapacity: 10
        }
      }]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

## Real-World Examples

### High-Performance DeFi Configuration

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: defi-prod
    networks:
      - architecture: evm
        evm:
          chainId: 1
        failsafe:
          # Aggressive hedging for all methods
          - matchers:
              - method: "*"
                action: include
            hedge:
              quantile: 0.9      # p90 latency
              minDelay: 50ms
              maxCount: 2        # Up to 2 parallel hedges
            timeout:
              duration: 10s
    
    upstreams:
      - id: primary-node
        failsafe:
          # Price feeds need fast response
          - matchers:
              - method: "eth_call"
                action: include
            matchFinality: ["latest"]
            timeout:
              duration: 1s
            retry:
              maxAttempts: 1     # No time for retries
          
          # Block data can be slower but must succeed
          - matchMethod: "eth_getBlock*"
            timeout:
              duration: 5s
            retry:
              maxAttempts: 5
              delay: 100ms
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "defi-prod",
    networks: [{
      architecture: "evm",
      evm: { chainId: 1 },
      failsafe: [{
        matchers:
              - method: "*"
                action: include,
        hedge: {
          quantile: 0.9,      // p90 latency
          minDelay: "50ms",
          maxCount: 2         // Up to 2 parallel hedges
        },
        timeout: { duration: "10s" }
      }]
    }],
    upstreams: [{
      id: "primary-node",
      failsafe: [
        {
          matchMethod: "eth_call",
          matchFinality: ["latest"],
          timeout: { duration: "1s" },
          retry: { maxAttempts: 1 }   // No time for retries
        },
        {
          matchMethod: "eth_getBlock*",
          timeout: { duration: "5s" },
          retry: {
            maxAttempts: 5,
            delay: "100ms"
          }
        }
      ]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

### Finality-Based Configuration

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
failsafe:
  # Finalized data: relaxed policies
  - matchers:
              - method: "*"
                action: include
    matchFinality: ["finalized"]
    timeout:
      duration: 30s
    retry:
      maxAttempts: 5
      backoffFactor: 2
  
  # Unfinalized data: aggressive timeouts
  - matchers:
              - method: "*"
                action: include
    matchFinality: ["unfinalized"]
    timeout:
      duration: 5s
    retry:
      maxAttempts: 2
      delay: 100ms
  
  # Realtime data: fast with hedging
  - matchers:
              - method: "*"
                action: include
    matchFinality: ["realtime"]
    timeout:
      duration: 2s
    hedge:
      delay: 500ms
      maxCount: 1
  
  # Unknown finality: moderate settings
  - matchers:
              - method: "*"
                action: include
    matchFinality: ["unknown"]
    timeout:
      duration: 15s
    retry:
      maxAttempts: 3
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
failsafe: [
  // Finalized data: relaxed policies
  {
    matchers:
              - method: "*"
                action: include,
    matchFinality: ["finalized"],
    timeout: { duration: "30s" },
    retry: {
      maxAttempts: 5,
      backoffFactor: 2
    }
  },
  // Unfinalized data: aggressive timeouts
  {
    matchers:
              - method: "*"
                action: include,
    matchFinality: ["unfinalized"],
    timeout: { duration: "5s" },
    retry: {
      maxAttempts: 2,
      delay: "100ms"
    }
  },
  // Realtime data: fast with hedging
  {
    matchers:
              - method: "*"
                action: include,
    matchFinality: ["realtime"],
    timeout: { duration: "2s" },
    hedge: {
      delay: "500ms",
      maxCount: 1
    }
  },
  // Unknown finality: moderate settings
  {
    matchers:
              - method: "*"
                action: include,
    matchFinality: ["unknown"],
    timeout: { duration: "15s" },
    retry: { maxAttempts: 3 }
  }
]
```
  </Tabs.Tab>
</Tabs>

### Indexer Configuration

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: indexer
    upstreams:
      - id: archive-node
        failsafe:
          # Bulk log queries need long timeouts
          - matchMethod: "eth_getLogs"
            timeout:
              duration: 120s
            retry:
              maxAttempts: 3
              backoffFactor: 2
          
          # Trace methods are expensive but critical
          - matchMethod: "trace_*|arbtrace_*"
            timeout:
              duration: 180s
            retry:
              maxAttempts: 2
            circuitBreaker:
              failureThresholdCount: 10    # More tolerant for slow methods
              failureThresholdCapacity: 20
              halfOpenAfter: 5m
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "indexer",
    upstreams: [{
      id: "archive-node",
      failsafe: [
        {
          matchMethod: "eth_getLogs",
          timeout: { duration: "120s" },
          retry: {
            maxAttempts: 3,
            backoffFactor: 2
          }
        },
        {
          matchMethod: "trace_*|arbtrace_*",
          timeout: { duration: "180s" },
          retry: { maxAttempts: 2 },
          circuitBreaker: {
            failureThresholdCount: 10,
            failureThresholdCapacity: 20,
            halfOpenAfter: "5m"
          }
        }
      ]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

## Disabling Policies

To disable any policy, set it to `null` or `~` (YAML):

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
failsafe:
  - matchers:
              - method: "*"
                action: include
    hedge: ~              # Disable hedging
    circuitBreaker: ~     # Disable circuit breaker
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
failsafe: [{
  matchers:
              - method: "*"
                action: include,
  hedge: null,           // Disable hedging
  circuitBreaker: null   // Disable circuit breaker
}]
```
  </Tabs.Tab>
</Tabs>
