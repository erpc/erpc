---
description: Consensus policy compares responses from multiple upstreams and returns the agreed result
---

import { Callout, Tabs, Tab } from "nextra/components";

# Consensus

The `consensus` policy sends the same request to multiple upstreams and returns the result only when enough of them agree. This ensures data consistency and detects misbehaving nodes.

<Callout type="warning">
  Consensus can only be configured at **network level** since it requires multiple upstreams to compare results.
</Callout>

```mermaid
flowchart TD
    Start([Request Starts]) --> Launch[Launch Consensus Participants]
    Launch --> Collect[Collect Responses from Upstreams]
    
    Collect --> CheckShortCircuit{Short Circuit Check<br/>Non-empty consensus reached?}
    CheckShortCircuit -->|Yes, Non-empty consensus| ShortCircuit[Cancel remaining requests<br/>Return consensus result]
    CheckShortCircuit -->|No, or Empty consensus| WaitAll[Wait for all responses]
    
    WaitAll --> CountParticipants[Count Valid Participants<br/>Exclude network errors]
    CountParticipants --> CheckMinParticipants{Participants >= RequiredParticipants?}
    
    CheckMinParticipants -->|No| LowParticipants[Handle Low Participants]
    CheckMinParticipants -->|Yes| CountByHash[Count Responses by Hash<br/>Separate Empty vs Non-empty]
    
    CountByHash --> NonEmptyPreference{Any Non-empty Results?}
    NonEmptyPreference -->|Yes| UseNonEmpty[Use Non-empty Results<br/>Ignore empty responses]
    NonEmptyPreference -->|No| UseEmpty[Use Empty Results]
    
    UseNonEmpty --> CheckConsensus{Most Common Count >= AgreementThreshold?}
    UseEmpty --> CheckConsensus
    
    CheckConsensus -->|Yes| ConsensusReached[Consensus Reached<br/>Return most common result]
    CheckConsensus -->|No| HandleDispute[Handle Dispute]
    
    %% Low Participants Handling
    LowParticipants --> LowParticipantsBehavior{LowParticipantsBehavior}
    LowParticipantsBehavior -->|returnError| LowParticipantsError[Return Low Participants Error]
    LowParticipantsBehavior -->|acceptMostCommonValidResult| LowAcceptMostCommon[Accept Most Common<br/>Check if meets threshold]
    LowParticipantsBehavior -->|acceptAnyValidResult| LowAcceptAny[Accept Any Valid<br/>Prefer non-empty]
    LowParticipantsBehavior -->|preferBlockHeadLeader| LowPreferLeader[Use Block Head Leader<br/>Fallback to most common]
    LowParticipantsBehavior -->|onlyBlockHeadLeader| LowOnlyLeader[Only Block Head Leader<br/>Error if unavailable]
    
    %% Dispute Handling
    HandleDispute --> DisputeBehavior{DisputeBehavior}
    DisputeBehavior -->|returnError| DisputeError[Return Dispute Error]
    DisputeBehavior -->|acceptMostCommonValidResult| AcceptMostCommon[Accept Most Common Valid<br/>Must meet threshold<br/>Error if tie]
    DisputeBehavior -->|acceptAnyValidResult| AcceptAny[Accept Any Valid<br/>Prefer non-empty<br/>Reject empty in dispute]
    DisputeBehavior -->|preferBlockHeadLeader| PreferLeader[Use Block Head Leader<br/>Fallback to most common]
    DisputeBehavior -->|onlyBlockHeadLeader| OnlyLeader[Only Block Head Leader<br/>Error if unavailable]
    
    %% Detailed AcceptMostCommon Logic
    AcceptMostCommon --> MostCommonLogic{Non-empty results exist?}
    MostCommonLogic -->|Yes| CheckNonEmptyThreshold{Most common non-empty<br/>meets threshold?}
    MostCommonLogic -->|No| CheckEmptyThreshold{Most common empty<br/>meets threshold?}
    
    CheckNonEmptyThreshold -->|Yes| ReturnNonEmpty[Return most common non-empty]
    CheckNonEmptyThreshold -->|No| MostCommonError[Return Error<br/>Insufficient agreement]
    
    CheckEmptyThreshold -->|Yes| CheckEmptyTie{Multiple empty results<br/>with same count?}
    CheckEmptyThreshold -->|No| MostCommonError
    
    CheckEmptyTie -->|No| ReturnEmpty[Return most common empty]
    CheckEmptyTie -->|Yes| MostCommonError
    
    %% Detailed AcceptAny Logic
    AcceptAny --> AnyLogic{Any non-empty success?}
    AnyLogic -->|Yes| ReturnFirstNonEmpty[Return first non-empty result]
    AnyLogic -->|No| CheckConsensusErrors{Any consensus-valid errors?}
    
    CheckConsensusErrors -->|Yes| ReturnConsensusError[Return consensus-valid error]
    CheckConsensusErrors -->|No| AcceptAnyError[Return Error<br/>No valid results]
    
    %% Block Head Leader Logic
    PreferLeader --> FindLeader{Block Head Leader available?}
    OnlyLeader --> FindLeader
    LowPreferLeader --> FindLeader
    LowOnlyLeader --> FindLeader
    
    FindLeader -->|Yes| UseLeader[Use Block Head Leader result]
    FindLeader -->|No, prefer*| FallbackMostCommon[Fallback to most common]
    FindLeader -->|No, only*| LeaderError[Return Error<br/>Leader unavailable]
    
    %% Error Consensus Handling
    CountByHash --> CheckErrorConsensus{Agreed-upon errors<br/>reach consensus?}
    CheckErrorConsensus -->|Yes| ReturnErrorConsensus[Return consensus error]
    CheckErrorConsensus -->|No| ContinueNormalFlow[Continue normal flow]
    
    %% Final Results
    ShortCircuit --> End([Return Result])
    ConsensusReached --> End
    ReturnNonEmpty --> End
    ReturnEmpty --> End
    ReturnFirstNonEmpty --> End
    UseLeader --> End
    ReturnErrorConsensus --> End
    ReturnConsensusError --> End
    
    %% Error Endings
    LowParticipantsError --> ErrorEnd([Return Error])
    DisputeError --> ErrorEnd
    MostCommonError --> ErrorEnd
    AcceptAnyError --> ErrorEnd
    LeaderError --> ErrorEnd
    
    %% Styling
    classDef startEnd fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef decision fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef process fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef error fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef success fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    
    class Start,End startEnd
    class ErrorEnd error
    class CheckShortCircuit,CheckMinParticipants,NonEmptyPreference,CheckConsensus,LowParticipantsBehavior,DisputeBehavior,MostCommonLogic,AnyLogic,FindLeader,CheckErrorConsensus decision
    class Launch,Collect,WaitAll,CountParticipants,CountByHash,UseNonEmpty,UseEmpty,HandleDispute,LowParticipants process
    class ConsensusReached,ReturnNonEmpty,ReturnEmpty,ReturnFirstNonEmpty,UseLeader,ReturnErrorConsensus,ReturnConsensusError,ShortCircuit success
    class LowParticipantsError,DisputeError,MostCommonError,AcceptAnyError,LeaderError error
```

## Configuration

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="GlobalConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
projects:
  - id: main
    networks:
      - architecture: evm
        evm:
          chainId: 42161
        failsafe:
          - matchMethod: "*" # Define different consensus thresholds for different methods
            matchFinality: ["finalized", "unknown"] # Read more in Failsafe docs -> Finality states
            consensus:
              requiredParticipants: 4
              agreementThreshold: 2
              disputeBehavior: returnError
              lowParticipantsBehavior: acceptAnyValidResult
              punishMisbehavior:
                disputeThreshold: 10
                disputeWindow: 10m
                sitOutPenalty: 30m
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
import { createConfig } from "@erpc-cloud/config";

export default createConfig({
  projects: [{
    id: "main",
    networks: [
      {
        architecture: "evm",
        evm: { chainId: 42161 },
        failsafe: [
          {
            matchMethod: "*",      // Can be configured per-method
            consensus: {
              requiredParticipants: 3,
              agreementThreshold: 2,
              disputeBehavior: "acceptAnyValidResult",
              lowParticipantsBehavior: "acceptMostCommonValidResult",
              punishMisbehavior: {
                disputeThreshold: 3,
                disputeWindow: "10s",
                sitOutPenalty: "30s"
              }
            }
          }
        ]
      }
    ]
  }]
});
```
  </Tabs.Tab>
</Tabs>

## Participation options

### `requiredParticipants`
Number of upstreams to query in each consensus round. The policy selects the first N healthy upstreams based on their scores.

### `agreementThreshold`
Minimum number of identical responses needed to reach consensus. For example, with `requiredParticipants: 3` and `agreementThreshold: 2`, at least 2 upstreams must return the same result.

<Callout type="info">
  Response comparison uses canonical JSON-RPC hashing. **Non-empty responses are always preferred over empty ones**, regardless of count (e.g., 1 non-empty beats 3 empty responses).
</Callout>

## Behavior options

### `disputeBehavior`
When upstreams disagree (no consensus reached):

- **`returnError`**: Returns dispute error. Strict agreement required among upstreams.
- **`acceptMostCommonValidResult`**: Returns most common response if it meets `agreementThreshold`. Prefers non-empty over empty responses. Errors if no clear winner.
- **`acceptAnyValidResult`**: Returns any valid response, preferring non-empty. Lenient fallback.
- **`preferBlockHeadLeader`**: Uses highest block number upstream, falls back to most common.
- **`onlyBlockHeadLeader`**: Only uses highest block upstream, errors otherwise.

### `lowParticipantsBehavior`
When fewer than `agreementThreshold` responses are available:

- **`returnError`**: Fails request. Strict participation requirement.
- **`acceptMostCommonValidResult`**: Uses available upstreams, returns most common if meets threshold. Same non-empty preference and clear winner rules as dispute behavior.
- **`acceptAnyValidResult`**: Uses any available upstream, prefers non-empty. Maximum availability.
- **`preferBlockHeadLeader`**: Uses response from block head leader if available, otherwise use most common response.
- **`onlyBlockHeadLeader`**: Only proceeds if block head leader is agrees with the response.

<Callout type="info">
  **Block Head Leader**: The upstream reporting the highest block number. This is determined by each upstream's state poller and ensures you're getting data from the most synchronized node.
</Callout>

## Misbehavior tracking

### `punishMisbehavior`
Temporarily removes upstreams that consistently disagree with the consensus:

- **`disputeThreshold`**: Number of disputes before punishment (e.g., 3 strikes)
- **`disputeWindow`**: Time window for counting disputes (e.g., 10m)
- **`sitOutPenalty`**: How long the upstream is cordoned (e.g., 30m)

## Chain reorganizations
During reorgs, nodes may temporarily disagree on recent blocks. Using `preferBlockHeadLeader` helps resolve disputes by using the response from most up-to-date upstream.

## Performance
Consensus increases costs and latency since it waits for multiple responses. Use it selectively for critical workloads and specific methods rather than all requests.
