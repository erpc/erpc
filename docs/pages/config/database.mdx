import { Callout } from "nextra/components";

# Database

Long-term storage is optional but used for various purposes such as caching, rate limit persistence, etc.

```yaml filename="erpc.yaml"
# ...
database:
  evmJsonRpcCache:
    connectors:
      - id: string
        driver: memory | redis | postgresql | dynamodb
        # ... (driver specific config, see below)
    policies:
      - network: string
        method: string
        params: []any
        finality: finalized | unfinalized | unknown
        allowEmptyish: boolean
        connector: string
        ttl: duration
```

### `evmJsonRpcCache`

This config defines the destination for caching JSON-RPC calls towards any EVM architecture upstream.
Caching mechanism is non-blocking on critical path, and is used as best-effort. If the database is not available, the cache set/get will be skipped.

<Callout type="info">
  Make sure the storage requirements meet your usage, for example caching 70m
  blocks + 10m txs + 10m traces on Arbitrum needs 200GB of storage.
</Callout>

The cache config allows you to define multiple connectors (storage backends) and policies for different finality states. Here's the basic structure:

```yaml filename="erpc.yaml"
database:
  evmJsonRpcCache:
    # Define one or more storage connectors with unique IDs useful in policies
    connectors:
      - id: memory-cache
        driver: memory # Refer to "memory" driver docs below
        memory:
          maxItems: 100000
      - id: redis-cache-local
        driver: redis # Refer to "redis" driver docs below
        redis:
          addr: localhost:6379
          password: "xxxxxxxxx"
          db: 0
          connPoolSize: 128
      - id: redis-cache-momento
        driver: redis # Refer to "redis" driver docs below
        redis:
          addr: momento.aws.momentohq.com:6379
          password: "xxxxxxxxx"
          db: 0
          connPoolSize: 128
      - id: postgres-cache
        driver: postgresql # Refer to "postgresql" driver docs below
        postgresql:
          connectionUri: >-
            postgres://YOUR_USERNAME_HERE:YOUR_PASSWORD_HERE@your.postgres.hostname.here.com:5432/your_database_name
          table: rpc_cache
      # ... any driver can be used multiple times
    
    # Define caching policies for different network/method/finality states
    policies:
      - network: "*"
        method: "*"
        finality: finalized
        connector: memory-cache
        ttl: 0
      - network: "*"
        method: "*"
        finality: unfinalized
        connector: memory-cache
        ttl: 30s
      - network: "*"
        method: "*"
        finality: unknown
        connector: memory-cache
        ttl: 30s
      - network: "*" # supports * as wildcard and | as OR operator
        method: "eth_getLogs|trace_*" # supports * as wildcard and | as OR operator
        finality: finalized
        connector: postgres-cache
        ttl: 0
      - network: "evm:42161|evm:10" # supports * as wildcard and | as OR operator
        method: "arbtrace_*" # supports * as wildcard and | as OR operator
        finality: finalized
        connector: postgres-cache
        ttl: 1d
```

<Callout type="info">
By default, eRPC enables an in-memory cache with these policies:
- Finalized data: cached forever with 100k max items
- Unknown/Unfinalized data: cached for 30 seconds to be reorg safe
</Callout>

#### Cache policies

You can create multiple policies to define different caching behavior for different networks, methods, and finality states.

* On each cache "set" operation all policies that match the network/method/finality state will be used to store the data.
* On each cache "get" operation all policies that match the network/method will be used to retrieve the data, from top to bottom as defined in the config, the first policy that returns a cache hit will be used.

#### Policy matching

Each policy can define matching rules for:

```yaml filename="erpc.yaml"
policies:
  - network: "evm:42161|evm:10" # (OPTIONAL) Network ID matching
    method: "eth_getLogs|trace_*" # (OPTIONAL) Method name matching
    params: # (OPTIONAL) parameter matching
      - ">=0x100|<=0x200" # First parameter
      - "*" # Second parameter
      # ... additional param matchers
    finality: finalized
    connector: postgres-cache
    ttl: 1d
```

##### Parameter Matching

The `params` field allows you to define matching rules for RPC method parameters. This is useful for creating granular caching policies based on specific parameter values:

```yaml filename="erpc.yaml"
database:
  evmJsonRpcCache:
    policies:
      # Cache eth_getLogs requests for specific block ranges
      - network: "*"
        method: "eth_getLogs"
        params:
          - fromBlock: ">=0x100"
            toBlock: "<=0x200"
        finality: finalized
        connector: postgres-cache
        ttl: 1d
      
      # Cache eth_getBlockByNumber for specific blocks
      - network: "*"
        method: "eth_getBlockByNumber"
        params:
          - ">=0x100|<=0x200" # Block number range
          - "*" # Include details flag
        finality: finalized
        connector: redis-cache
        ttl: 1h
```

The parameter matcher supports:

* **Wildcards**: Use `*` to match any value
* **OR operator**: Use `|` to specify multiple valid values
* **Numeric comparisons**: For hex/decimal numbers:
  * `>value` - Greater than
  * `>=value` - Greater than or equal
  * `<value` - Less than  
  * `<=value` - Less than or equal
* **Object matching**: For nested parameter objects (like in eth_getLogs), you can specify matchers for individual fields
* **Array matching**: For array parameters, each element can have its own matcher
* **Empty values**: Use `<empty>` to match null/undefined values

##### Examples

Here are some example parameter matching patterns:

```yaml filename="erpc.yaml"
# Match specific block numbers
params: ["0x1|0x2|0x3", "*"]

# Match block number ranges
params: [">=0x100|<=0x200", "*"]

# Match eth_getLogs with specific criteria
params:
  - fromBlock: ">=0x100"
    toBlock: "<=0x200"
    address: "*"
    topics: ["*"]

# Match array parameters:
params: [[">0x123", ">=0x456"], "*"]

# Match empty parameters:
params: ["*", "<empty>"]
```



#### Finality states

The cache system recognizes three finality states:

- `finalized`: Data from blocks that are confirmed as finalized (safe to cache long-term). This is based on 'finalized' block fetched via eth_getBlockByNumber of the upstream corresponding to the received response (not other upstreams).
- `unfinalized`: Data from recent blocks that could still be reorged, any data/transaction from pending blocks is considered unfinalized.
- `unknown`: When block number cannot be determined from request/response (e.g., `eth_traceTransaction`). Most often it is safe to cache this data without reorg safety because they are not referenced by final actual blocks.

#### Re-org mechanism

TODO explain how to deal with reorgs with multiple policies

For chains which do not support "finalized" block method, eRPC will consider last 1024 blocks unfinalized. This number can be configured via `network.evm.fallbackFinalityDepth`.

#### Cacheable methods
Methods are cached if they include a `blockNumber` or `blockHash` in the request or response, allowing cache invalidation during blockchain reorgs. If no blockNumber is present, caching is still viable if the method returns data unaffected by reorgs, like `eth_chainId`, or if the data won't change after a reorg, such as `eth_getTransactionReceipt`. Here is an overview of cacheable methods:

| Method Name                                 | Description                                                                                                                                           |
|---------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| `eth_getTransactionReceipt`                 | Retrieves the receipt of a transaction by its hash.                                                                                                   |
| `eth_getTransactionByHash`                  | Retrieves a transaction based on its hash.                                                                                                            |
| `arbtrace_replayTransaction`                | Replays a transaction on the blockchain (specific to Arbitrum).                                                                                       |
| `trace_replayTransaction`                   | Replays a transaction and returns the trace of execution.                                                                                             |
| `debug_traceTransaction`                    | Traces the execution of a transaction.                                                                                                                |
| `trace_transaction`                         | Returns the trace of a transaction by its hash.                                                                                                       |
| `eth_chainId`                               | Returns the chain ID of the network.                                                                                                                  |
| `eth_getBlockByNumber`                      | Retrieves a block by its number.                                                                                                                      |
| `eth_getUncleByBlockNumberAndIndex`         | Retrieves an uncle block by its number and index.                                                                                                      |
| `eth_getTransactionByBlockNumberAndIndex`   | Retrieves a transaction by block number and transaction index.                                                                                        |
| `eth_getUncleCountByBlockNumber`            | Retrieves the number of uncles in a block by block number.                                                                                            |
| `eth_getBlockTransactionCountByNumber`      | Retrieves the number of transactions in a block by block number.                                                                                      |
| `eth_getBlockReceipts`                      | Retrieves all receipts for a block by block number.                                                                                                   |
| `eth_getLogs`                               | Retrieves logs based on filter criteria.                                                                                                              |
| `eth_getBalance`                            | Retrieves the balance of an account at a specified block.                                                                                             |
| `eth_getCode`                               | Retrieves the code at a given address at a specified block.                                                                                           |
| `eth_getTransactionCount`                   | Retrieves the number of transactions sent from an address at a specified block.                                                                        |
| `eth_call`                                  | Executes a new message call immediately without creating a transaction on the blockchain.                                                             |
| `eth_feeHistory`                            | Returns the history of gas fees.                                                                                                                      |
| `eth_getAccount`                            | Retrieves account information at a specified block.                                                                                                   |
| `eth_getBlockByHash`                        | Retrieves a block by its hash.                                                                                                                        |
| `eth_getTransactionByBlockHashAndIndex`     | Retrieves a transaction by block hash and transaction index.                                                                                          |
| `eth_getBlockTransactionCountByHash`        | Retrieves the number of transactions in a block by block hash.                                                                                        |
| `eth_getUncleCountByBlockHash`              | Retrieves the number of uncles in a block by block hash.                                                                                              |
| `eth_getProof`                              | Retrieves the proof for an account and its storage.                                                                                                   |
| `eth_getStorageAt`                          | Retrieves the value from a storage position at a specified address and block.                                                                         |


## Drivers

Depending on your use-case you can use different drivers.

### Memory

Mainly useful for local testing or when you don't need to cache too much data.

```yaml filename="erpc.yaml"
# ...
database:
  evmJsonRpcCache:
    connectors:
      - id: memory-cache
        driver: memory
        memory:
          maxItems: 10000
```

### Redis

Redis is useful when you need to store cached data temporarily with **eviction policy** (e.g. certain amount of memory).

```yaml filename="erpc.yaml"
# ...
database:
  evmJsonRpcCache:
    connectors:
      - id: redis-cache
        driver: redis
        redis:
          addr: YOUR_REDIS_ADDRESS_HERE
          password: YOUR_REDIS_PASSWORD_HERE
          db: XXX
          connPoolSize: 128
# ...
```

Example of Redis config with eviction policy:
```conf
maxmemory 2000mb
maxmemory-policy allkeys-lru
```

### PostgreSQL

Useful when you need to store cached data permanently without TTL i.e. forever.

<Callout type="info">
  You don't need to create the table, the driver will automatically create the
  table and requried indexes.
</Callout>

```yaml filename="erpc.yaml"
# ...
database:
  evmJsonRpcCache:
    connectors:
      - id: postgres-cache
        driver: postgresql
        postgresql:
          connectionUri: >-
            postgres://YOUR_USERNAME_HERE:YOUR_PASSWORD_HERE@your.postgres.hostname.here.com:5432/your_database_name
          table: rpc_cache
# ...
```

### DynamoDB

When you need to have scalable (compared to Postgres) permanent caching and are happy with the costs.

```yaml filename="erpc.yaml"
# ...
database:
  evmJsonRpcCache:
    connectors:
      - id: dynamodb-cache
        driver: dynamodb
        dynamodb:
          table: rpc_cache
          region: eu-west-1
          endpoint: https://dynamodb.eu-west-1.amazonaws.com # Optional
          # Auth is optional if you are running within AWS.
          auth:
            mode: secret # file, or env
            accessKeyId: YOUR_ACCESS_KEY_ID # Only if mode is secret
            secretAccessKey: YOUR_SECRET_ACCESS_KEY # Only if mode is secret
            profile: xxxxx # Only if mode is file
            credentialsFile: xxxx # Only if mode is file
```
