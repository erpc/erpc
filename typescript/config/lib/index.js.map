{
  "version": 3,
  "sources": ["../src/index.ts", "../src/generated.ts"],
  "sourcesContent": ["export * from './types'\nexport type * from './types'\nexport {\n  DataFinalityStateUnfinalized,\n  DataFinalityStateFinalized,\n  DataFinalityStateUnknown,\n  DataFinalityStateRealtime,\n  CacheEmptyBehaviorAllow,\n  CacheEmptyBehaviorIgnore,\n  CacheEmptyBehaviorOnly,\n} from './generated'\nexport type {\n  CacheConfig,\n  Config,\n} from './generated'\n\nimport type { Config } from './generated'\n\nexport const createConfig = (\n  cfg: Config\n): Config => {\n  return cfg;\n};", "// Code generated by tygo. DO NOT EDIT.\nexport * from \"./types\"\nimport * as types from \"./types\"\n\n//////////\n// source: cache_dal.go\n\nexport type CacheDAL = any;\n\n//////////\n// source: cache_mock.go\n\nexport interface MockCacheDal {\n  mock: any /* mock.Mock */;\n}\n\n//////////\n// source: config.go\n\n/**\n * Config represents the configuration of the application.\n */\nexport interface Config {\n  logLevel: types.LogLevel;\n  server?: ServerConfig;\n  admin?: AdminConfig;\n  database?: DatabaseConfig;\n  projects: (ProjectConfig | undefined)[];\n  rateLimiters?: RateLimiterConfig;\n  metrics?: MetricsConfig;\n}\nexport interface ServerConfig {\n  listenV4?: boolean;\n  httpHostV4?: string;\n  listenV6?: boolean;\n  httpHostV6?: string;\n  httpPort?: number /* int */;\n  maxTimeout?: string;\n  readTimeout?: string;\n  writeTimeout?: string;\n  enableGzip?: boolean;\n  tls?: TLSConfig;\n  aliasing?: AliasingConfig;\n}\nexport interface AdminConfig {\n  auth?: AuthConfig;\n  cors?: CORSConfig;\n}\nexport interface AliasingConfig {\n  rules: (AliasingRuleConfig | undefined)[];\n}\nexport interface AliasingRuleConfig {\n  matchDomain: string;\n  serveProject: string;\n  serveArchitecture: string;\n  serveChain: string;\n}\nexport interface DatabaseConfig {\n  evmJsonRpcCache?: CacheConfig;\n}\nexport interface CacheConfig {\n  connectors?: types.ConnectorConfig[];\n  policies?: (CachePolicyConfig | undefined)[];\n  methods?: { [key: string]: CacheMethodConfig | undefined};\n}\nexport interface CacheMethodConfig {\n  reqRefs: any[][];\n  respRefs: any[][];\n  finalized: boolean;\n  realtime: boolean;\n}\nexport interface CachePolicyConfig {\n  connector: string;\n  network?: string;\n  method?: string;\n  params?: any[];\n  finality?: DataFinalityState;\n  empty?: CacheEmptyBehavior;\n  minItemSize?: string;\n  maxItemSize?: string;\n  ttl?: types.Duration;\n}\nexport type ConnectorDriverType = string;\nexport const DriverMemory: ConnectorDriverType = \"memory\";\nexport const DriverRedis: ConnectorDriverType = \"redis\";\nexport const DriverPostgreSQL: ConnectorDriverType = \"postgresql\";\nexport const DriverDynamoDB: ConnectorDriverType = \"dynamodb\";\nexport interface ConnectorConfig {\n  id: string;\n  driver: ConnectorDriverType;\n  memory?: MemoryConnectorConfig;\n  redis?: RedisConnectorConfig;\n  dynamodb?: DynamoDBConnectorConfig;\n  postgresql?: PostgreSQLConnectorConfig;\n}\nexport interface MemoryConnectorConfig {\n  maxItems: number /* int */;\n}\nexport interface TLSConfig {\n  enabled: boolean;\n  certFile: string;\n  keyFile: string;\n  caFile?: string;\n  insecureSkipVerify?: boolean;\n}\nexport interface RedisConnectorConfig {\n  addr: string;\n  db: number /* int */;\n  tls?: TLSConfig;\n  connPoolSize: number /* int */;\n}\nexport interface DynamoDBConnectorConfig {\n  table: string;\n  region: string;\n  endpoint: string;\n  auth?: AwsAuthConfig;\n  partitionKeyName: string;\n  rangeKeyName: string;\n  reverseIndexName: string;\n  ttlAttributeName: string;\n}\nexport interface PostgreSQLConnectorConfig {\n  connectionUri: string;\n  table: string;\n  minConns?: number /* int32 */;\n  maxConns?: number /* int32 */;\n}\nexport interface AwsAuthConfig {\n  mode: string; // \"file\", \"env\", \"secret\"\n  credentialsFile: string;\n  profile: string;\n  accessKeyID: string;\n  secretAccessKey: string;\n}\nexport interface ProjectConfig {\n  id: string;\n  auth?: AuthConfig;\n  cors?: CORSConfig;\n  upstreamDefaults?: UpstreamConfig;\n  upstreams: (UpstreamConfig | undefined)[];\n  networkDefaults?: NetworkDefaults;\n  networks?: (NetworkConfig | undefined)[];\n  rateLimitBudget?: string;\n  healthCheck?: HealthCheckConfig;\n}\nexport interface NetworkDefaults {\n  rateLimitBudget?: string;\n  failsafe?: FailsafeConfig;\n  selectionPolicy?: SelectionPolicyConfig;\n  directiveDefaults?: DirectiveDefaultsConfig;\n}\nexport interface CORSConfig {\n  allowedOrigins: string[];\n  allowedMethods: string[];\n  allowedHeaders: string[];\n  exposedHeaders: string[];\n  allowCredentials?: boolean;\n  maxAge: number /* int */;\n}\nexport interface UpstreamConfig {\n  id?: string;\n  type?: UpstreamType;\n  group?: string;\n  vendorName?: string;\n  endpoint: string;\n  evm?: EvmUpstreamConfig;\n  jsonRpc?: JsonRpcUpstreamConfig;\n  ignoreMethods?: string[];\n  allowMethods?: string[];\n  autoIgnoreUnsupportedMethods?: boolean;\n  failsafe?: FailsafeConfig;\n  rateLimitBudget?: string;\n  rateLimitAutoTune?: RateLimitAutoTuneConfig;\n  routing?: RoutingConfig;\n}\nexport interface RoutingConfig {\n  scoreMultipliers: (ScoreMultiplierConfig | undefined)[];\n}\nexport interface ScoreMultiplierConfig {\n  network: string;\n  method: string;\n  overall: number /* float64 */;\n  errorRate: number /* float64 */;\n  p90latency: number /* float64 */;\n  totalRequests: number /* float64 */;\n  throttledRate: number /* float64 */;\n  blockHeadLag: number /* float64 */;\n  finalizationLag: number /* float64 */;\n}\nexport type Alias = UpstreamConfig;\nexport interface RateLimitAutoTuneConfig {\n  enabled?: boolean;\n  adjustmentPeriod: string;\n  errorRateThreshold: number /* float64 */;\n  increaseFactor: number /* float64 */;\n  decreaseFactor: number /* float64 */;\n  minBudget: number /* int */;\n  maxBudget: number /* int */;\n}\nexport interface JsonRpcUpstreamConfig {\n  supportsBatch?: boolean;\n  batchMaxSize?: number /* int */;\n  batchMaxWait?: string;\n  enableGzip?: boolean;\n}\nexport interface EvmUpstreamConfig {\n  chainId: number /* int */;\n  nodeType?: EvmNodeType;\n  statePollerInterval?: string;\n  maxAvailableRecentBlocks?: number /* int64 */;\n}\nexport interface FailsafeConfig {\n  retry?: RetryPolicyConfig;\n  circuitBreaker?: CircuitBreakerPolicyConfig;\n  timeout?: TimeoutPolicyConfig;\n  hedge?: HedgePolicyConfig;\n}\nexport interface RetryPolicyConfig {\n  maxAttempts: number /* int */;\n  delay: string;\n  backoffMaxDelay: string;\n  backoffFactor: number /* float32 */;\n  jitter: string;\n}\nexport interface CircuitBreakerPolicyConfig {\n  failureThresholdCount: number /* uint */;\n  failureThresholdCapacity: number /* uint */;\n  halfOpenAfter: string;\n  successThresholdCount: number /* uint */;\n  successThresholdCapacity: number /* uint */;\n}\nexport interface TimeoutPolicyConfig {\n  duration: string;\n}\nexport interface HedgePolicyConfig {\n  delay: string;\n  maxCount: number /* int */;\n}\nexport interface RateLimiterConfig {\n  budgets: (RateLimitBudgetConfig | undefined)[];\n}\nexport interface RateLimitBudgetConfig {\n  id: string;\n  rules: (RateLimitRuleConfig | undefined)[];\n}\nexport interface RateLimitRuleConfig {\n  method: string;\n  maxCount: number /* uint */;\n  period: string;\n  waitTime: string;\n}\nexport interface HealthCheckConfig {\n  scoreMetricsWindowSize: string;\n}\nexport interface NetworkConfig {\n  architecture: 'evm';\n  rateLimitBudget?: string;\n  failsafe?: FailsafeConfig;\n  evm?: EvmNetworkConfig;\n  selectionPolicy?: SelectionPolicyConfig;\n  directiveDefaults?: DirectiveDefaultsConfig;\n}\nexport interface DirectiveDefaultsConfig {\n  retryEmpty?: boolean;\n  retryPending?: boolean;\n  skipCacheRead?: boolean;\n  useUpstream?: string;\n}\nexport interface EvmNetworkConfig {\n  chainId: number /* int64 */;\n  fallbackFinalityDepth?: number /* int64 */;\n}\nexport interface SelectionPolicyConfig {\n  evalInterval?: types.Duration;\n  evalFunction?: types.SelectionPolicyEvalFunction | undefined;\n  evalPerMethod?: boolean;\n  resampleExcluded?: boolean;\n  resampleInterval?: types.Duration;\n  resampleCount?: number /* int */;\n}\nexport type AuthType = string;\nexport const AuthTypeSecret: AuthType = \"secret\";\nexport const AuthTypeJwt: AuthType = \"jwt\";\nexport const AuthTypeSiwe: AuthType = \"siwe\";\nexport const AuthTypeNetwork: AuthType = \"network\";\nexport interface AuthConfig {\n  strategies: (AuthStrategyConfig | undefined)[];\n}\nexport interface AuthStrategyConfig {\n  ignoreMethods?: string[];\n  allowMethods?: string[];\n  rateLimitBudget?: string;\n  type: AuthType;\n  network?: NetworkStrategyConfig;\n  secret?: SecretStrategyConfig;\n  jwt?: JwtStrategyConfig;\n  siwe?: SiweStrategyConfig;\n}\nexport interface SecretStrategyConfig {\n  value: string;\n}\nexport interface JwtStrategyConfig {\n  allowedIssuers: string[];\n  allowedAudiences: string[];\n  allowedAlgorithms: string[];\n  requiredClaims: string[];\n  verificationKeys: { [key: string]: string};\n}\nexport interface SiweStrategyConfig {\n  allowedDomains: string[];\n}\nexport interface NetworkStrategyConfig {\n  allowedIPs: string[];\n  allowedCIDRs: string[];\n  allowLocalhost: boolean;\n  trustedProxies: string[];\n}\nexport interface MetricsConfig {\n  enabled?: boolean;\n  listenV4?: boolean;\n  hostV4?: string;\n  listenV6?: boolean;\n  hostV6?: string;\n  port?: number /* int */;\n}\n\n//////////\n// source: data.go\n\nexport type DataFinalityState = number /* int */;\n/**\n * Finalized gets 0 intentionally so that when user has not specified finality,\n * it defaults to finalized, which is safest sane default for caching.\n * This attribute will be calculated based on extracted block number (from request and/or response)\n * and comparing to the upstream (one that returned the response) 'finalized' block (fetch via evm state poller).\n */\nexport const DataFinalityStateFinalized: DataFinalityState = 0;\n/**\n * When we CAN determine the block number, and it's after the upstream 'finalized' block, we consider the data unfinalized.\n */\nexport const DataFinalityStateUnfinalized: DataFinalityState = 1;\n/**\n * Certain methods points are meant to be realtime and updated with every new block (e.g. eth_gasPrice).\n * These can be cached with short TTLs to improve performance.\n */\nexport const DataFinalityStateRealtime: DataFinalityState = 2;\n/**\n * When we CANNOT determine the block number (e.g some trace by hash calls), we consider the data unknown.\n * Most often it is safe to cache this data for longer as they're access when block hash is provided directly.\n */\nexport const DataFinalityStateUnknown: DataFinalityState = 3;\nexport type CacheEmptyBehavior = number /* int */;\nexport const CacheEmptyBehaviorIgnore: CacheEmptyBehavior = 0;\nexport const CacheEmptyBehaviorAllow: CacheEmptyBehavior = 1;\nexport const CacheEmptyBehaviorOnly: CacheEmptyBehavior = 2;\n\n//////////\n// source: defaults.go\n\nexport const DefaultEvmFinalityDepth = 1024;\nexport const DefaultPolicyFunction = `\n\t(upstreams, method) => {\n\t\tconst defaults = upstreams.filter(u => u.config.group !== 'fallback')\n\t\tconst fallbacks = upstreams.filter(u => u.config.group === 'fallback')\n\t\t\n\t\tconst maxErrorRate = parseFloat(process.env.ROUTING_POLICY_MAX_ERROR_RATE || '0.7')\n\t\tconst maxBlockHeadLag = parseFloat(process.env.ROUTING_POLICY_MAX_BLOCK_HEAD_LAG || '10')\n\t\tconst minHealthyThreshold = parseInt(process.env.ROUTING_POLICY_MIN_HEALTHY_THRESHOLD || '1')\n\t\t\n\t\tconst healthyOnes = defaults.filter(\n\t\t\tu => u.metrics.errorRate < maxErrorRate && u.metrics.blockHeadLag < maxBlockHeadLag\n\t\t)\n\t\t\n\t\tif (healthyOnes.length >= minHealthyThreshold) {\n\t\t\treturn healthyOnes\n\t\t}\n\n\t\tif (fallbacks.length > 0) {\n\t\t\tlet healthyFallbacks = fallbacks.filter(\n\t\t\t\tu => u.metrics.errorRate < maxErrorRate && u.metrics.blockHeadLag < maxBlockHeadLag\n\t\t\t)\n\t\t\t\n\t\t\tif (healthyFallbacks.length > 0) {\n\t\t\t\treturn healthyFallbacks\n\t\t\t}\n\t\t}\n\n\t\t// The reason all upstreams are returned is to be less harsh and still consider default nodes (in case they have intermittent issues)\n\t\t// Order of upstreams does not matter as that will be decided by the upstream scoring mechanism\n\t\treturn upstreams\n\t}\n`;\n\n//////////\n// source: evm.go\n\nexport type EvmNodeType = string;\nexport const EvmNodeTypeFull: EvmNodeType = \"full\";\nexport const EvmNodeTypeArchive: EvmNodeType = \"archive\";\nexport const EvmNodeTypeLight: EvmNodeType = \"light\";\nexport type EvmStatePoller = any;\n\n//////////\n// source: matcher.go\n\n\n//////////\n// source: network.go\n\nexport type NetworkArchitecture = string;\nexport const ArchitectureEvm: NetworkArchitecture = \"evm\";\nexport type Network = any;\n\n//////////\n// source: upstream.go\n\nexport type Scope = string;\n/**\n * Policies must be created with a \"network\" in mind,\n * assuming there will be many upstreams e.g. Retry might endup using a different upstream\n */\nexport const ScopeNetwork: Scope = \"network\";\n/**\n * Policies must be created with one only \"upstream\" in mind\n * e.g. Retry with be towards the same upstream\n */\nexport const ScopeUpstream: Scope = \"upstream\";\nexport type UpstreamType = string;\nexport const UpstreamTypeEvm: UpstreamType = \"evm\";\nexport const UpstreamTypeEvmAlchemy: UpstreamType = \"evm+alchemy\";\nexport const UpstreamTypeEvmDrpc: UpstreamType = \"evm+drpc\";\nexport const UpstreamTypeEvmBlastapi: UpstreamType = \"evm+blastapi\";\nexport const UpstreamTypeEvmEnvio: UpstreamType = \"evm+envio\";\nexport const UpstreamTypeEvmPimlico: UpstreamType = \"evm+pimlico\";\nexport const UpstreamTypeEvmThirdweb: UpstreamType = \"evm+thirdweb\";\nexport const UpstreamTypeEvmEtherspot: UpstreamType = \"evm+etherspot\";\nexport const UpstreamTypeEvmInfura: UpstreamType = \"evm+infura\";\nexport type EvmSyncingState = number /* int */;\nexport const EvmSyncingStateUnknown: EvmSyncingState = 0;\nexport const EvmSyncingStateSyncing: EvmSyncingState = 1;\nexport const EvmSyncingStateNotSyncing: EvmSyncingState = 2;\nexport type Upstream = any;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACgVO,IAAM,6BAAgD;AAItD,IAAM,+BAAkD;AAKxD,IAAM,4BAA+C;AAKrD,IAAM,2BAA8C;AAEpD,IAAM,2BAA+C;AACrD,IAAM,0BAA8C;AACpD,IAAM,yBAA6C;;;ADhVnD,IAAM,eAAe,CAC1B,QACW;AACX,SAAO;AACT;",
  "names": []
}
