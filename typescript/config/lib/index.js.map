{
  "version": 3,
  "sources": ["../src/index.ts", "../src/generated.ts"],
  "sourcesContent": ["export type {\n  // Tygo generic replacement\n  LogLevel,\n  Duration,\n  ByteSize,\n  NetworkArchitecture,\n  ConnectorDriverType,\n  ConnectorConfig,\n  UpstreamType,\n  // Policy evaluation\n  PolicyEvalUpstreamMetrics,\n  PolicyEvalUpstream,\n  SelectionPolicyEvalFunction,\n  EvmNetworkConfigForDefaults,\n} from \"./types\";\nexport {\n  // Data finality const exports\n  DataFinalityStateUnfinalized,\n  DataFinalityStateFinalized,\n  DataFinalityStateRealtime,\n  DataFinalityStateUnknown,\n  // Scope exports\n  ScopeNetwork,\n  ScopeUpstream,\n  // Cache behavior exports\n  CacheEmptyBehaviorIgnore,\n  CacheEmptyBehaviorAllow,\n  CacheEmptyBehaviorOnly,\n  // Evm node type\n  EvmNodeTypeFull,\n  EvmNodeTypeArchive,\n  EvmNodeTypeUnknown,\n  // Evm syncing type\n  EvmSyncingStateUnknown,\n  EvmSyncingStateSyncing,\n  EvmSyncingStateNotSyncing,\n  // Architecture export\n  ArchitectureEvm,\n  // Upstream types const exprots\n  UpstreamTypeEvm,\n  // Auth types\n  AuthTypeSecret,\n  AuthTypeJwt,\n  AuthTypeSiwe,\n  AuthTypeNetwork,\n  // Consensus related\n  ConsensusLowParticipantsBehaviorReturnError,\n  ConsensusLowParticipantsBehaviorAcceptMostCommonValidResult,\n  ConsensusLowParticipantsBehaviorPreferBlockHeadLeader,\n  ConsensusLowParticipantsBehaviorOnlyBlockHeadLeader,\n  ConsensusDisputeBehaviorReturnError,\n  ConsensusDisputeBehaviorAcceptMostCommonValidResult,\n  ConsensusDisputeBehaviorPreferBlockHeadLeader,\n  ConsensusDisputeBehaviorOnlyBlockHeadLeader,\n} from \"./generated\";\nexport type {\n  Config,\n  ProjectConfig,\n  HealthCheckConfig,\n  // Provider related\n  ProviderConfig,\n  VendorSettings,\n  // Upstream related\n  UpstreamConfig,\n  EvmUpstreamConfig,\n  RoutingConfig,\n  ScoreMultiplierConfig,\n  RateLimitAutoTuneConfig,\n  JsonRpcUpstreamConfig,\n  // Failsafe related\n  FailsafeConfig,\n  RetryPolicyConfig,\n  CircuitBreakerPolicyConfig,\n  HedgePolicyConfig,\n  TimeoutPolicyConfig,\n  ConsensusPolicyConfig,\n  // Network related\n  NetworkConfig,\n  EvmNetworkConfig,\n  EvmIntegrityConfig,\n  SelectionPolicyConfig,\n  DirectiveDefaultsConfig,\n  // DB related\n  DatabaseConfig,\n  CacheConfig,\n  DataFinalityState,\n  CacheEmptyBehavior,\n  CachePolicyConfig,\n  MemoryConnectorConfig,\n  RedisConnectorConfig,\n  DynamoDBConnectorConfig,\n  AwsAuthConfig,\n  PostgreSQLConnectorConfig,\n  // Auth related\n  AuthStrategyConfig,\n  SecretStrategyConfig,\n  JwtStrategyConfig,\n  SiweStrategyConfig,\n  NetworkStrategyConfig,\n  // Rate limits related\n  RateLimiterConfig,\n  RateLimitBudgetConfig,\n  RateLimitRuleConfig,\n  // Server config related\n  ServerConfig,\n  CORSConfig,\n  MetricsConfig,\n  AdminConfig,\n  AliasingConfig,\n  AliasingRuleConfig,\n  TLSConfig,\n  // Proxy pools related\n  ProxyPoolConfig,\n} from \"./generated\";\n\nimport type { Config } from './generated'\n\nexport const createConfig = (\n  cfg: Config\n): Config => {\n  return cfg;\n};", "// Code generated by tygo. DO NOT EDIT.\nimport type { \n  LogLevel,\n  Duration,\n  ByteSize,\n  ConnectorDriverType as TsConnectorDriverType,\n  ConnectorConfig as TsConnectorConfig,\n  UpstreamType as TsUpstreamType,\n  NetworkArchitecture as TsNetworkArchitecture,\n  AuthType as TsAuthType,\n  AuthStrategyConfig as TsAuthStrategyConfig,\n  EvmNetworkConfigForDefaults as TsEvmNetworkConfigForDefaults,\n  SelectionPolicyEvalFunction\n} from \"./types\"\n\n//////////\n// source: architecture_evm.go\n\nexport const UpstreamTypeEvm: UpstreamType = \"evm\";\nexport type EvmUpstream = \n    Upstream;\nexport type AvailbilityConfidence = number /* int */;\nexport const AvailbilityConfidenceBlockHead: AvailbilityConfidence = 1;\nexport const AvailbilityConfidenceFinalized: AvailbilityConfidence = 2;\nexport type EvmNodeType = string;\nexport const EvmNodeTypeUnknown: EvmNodeType = \"unknown\";\nexport const EvmNodeTypeFull: EvmNodeType = \"full\";\nexport const EvmNodeTypeArchive: EvmNodeType = \"archive\";\nexport type EvmSyncingState = number /* int */;\nexport const EvmSyncingStateUnknown: EvmSyncingState = 0;\nexport const EvmSyncingStateSyncing: EvmSyncingState = 1;\nexport const EvmSyncingStateNotSyncing: EvmSyncingState = 2;\nexport type EvmStatePoller = any;\n\n//////////\n// source: cache_dal.go\n\nexport type CacheDAL = any;\n\n//////////\n// source: cache_mock.go\n\nexport interface MockCacheDal {\n  mock: any /* mock.Mock */;\n}\n\n//////////\n// source: config.go\n\n/**\n * Config represents the configuration of the application.\n */\nexport interface Config {\n  logLevel?: LogLevel;\n  clusterKey?: string;\n  server?: ServerConfig;\n  healthCheck?: HealthCheckConfig;\n  admin?: AdminConfig;\n  database?: DatabaseConfig;\n  projects?: (ProjectConfig | undefined)[];\n  rateLimiters?: RateLimiterConfig;\n  metrics?: MetricsConfig;\n  proxyPools?: (ProxyPoolConfig | undefined)[];\n  tracing?: TracingConfig;\n}\nexport interface ServerConfig {\n  listenV4?: boolean;\n  httpHostV4?: string;\n  listenV6?: boolean;\n  httpHostV6?: string;\n  httpPort?: number /* int */;\n  maxTimeout?: Duration;\n  readTimeout?: Duration;\n  writeTimeout?: Duration;\n  enableGzip?: boolean;\n  tls?: TLSConfig;\n  aliasing?: AliasingConfig;\n  waitBeforeShutdown?: Duration;\n  waitAfterShutdown?: Duration;\n  includeErrorDetails?: boolean;\n}\nexport interface HealthCheckConfig {\n  mode?: HealthCheckMode;\n  auth?: AuthConfig;\n  defaultEval?: string;\n}\nexport type HealthCheckMode = string;\nexport const HealthCheckModeSimple: HealthCheckMode = \"simple\";\nexport const HealthCheckModeVerbose: HealthCheckMode = \"verbose\";\nexport const EvalAnyInitializedUpstreams = \"any:initializedUpstreams\";\nexport const EvalAnyErrorRateBelow90 = \"any:errorRateBelow90\";\nexport const EvalAllErrorRateBelow90 = \"all:errorRateBelow90\";\nexport const EvalAnyErrorRateBelow100 = \"any:errorRateBelow100\";\nexport const EvalAllErrorRateBelow100 = \"all:errorRateBelow100\";\nexport const EvalEvmAnyChainId = \"any:evm:eth_chainId\";\nexport const EvalEvmAllChainId = \"all:evm:eth_chainId\";\nexport const EvalAllActiveUpstreams = \"all:activeUpstreams\";\nexport type TracingProtocol = string;\nexport const TracingProtocolHttp: TracingProtocol = \"http\";\nexport const TracingProtocolGrpc: TracingProtocol = \"grpc\";\nexport interface TracingConfig {\n  enabled?: boolean;\n  endpoint?: string;\n  protocol?: TracingProtocol;\n  sampleRate?: number /* float64 */;\n  detailed?: boolean;\n  tls?: TLSConfig;\n}\nexport interface AdminConfig {\n  auth?: AuthConfig;\n  cors?: CORSConfig;\n}\nexport interface AliasingConfig {\n  rules: (AliasingRuleConfig | undefined)[];\n}\nexport interface AliasingRuleConfig {\n  matchDomain: string;\n  serveProject: string;\n  serveArchitecture: string;\n  serveChain: string;\n}\nexport interface DatabaseConfig {\n  evmJsonRpcCache?: CacheConfig;\n  sharedState?: SharedStateConfig;\n}\nexport interface SharedStateConfig {\n  clusterKey?: string;\n  connector?: ConnectorConfig;\n  fallbackTimeout?: Duration;\n  lockTtl?: Duration;\n}\nexport interface CacheConfig {\n  connectors?: TsConnectorConfig[];\n  policies?: (CachePolicyConfig | undefined)[];\n  compression?: CompressionConfig;\n}\nexport interface CompressionConfig {\n  enabled?: boolean;\n  algorithm?: string; // \"zstd\" for now, can be extended\n  zstdLevel?: string; // \"fastest\", \"default\", \"better\", \"best\"\n  threshold?: number /* int */; // Minimum size in bytes to compress\n}\nexport interface CacheMethodConfig {\n  reqRefs: any[][];\n  respRefs: any[][];\n  finalized: boolean;\n  realtime: boolean;\n}\nexport interface CachePolicyConfig {\n  connector: string;\n  network?: string;\n  method?: string;\n  params?: any[];\n  finality?: DataFinalityState;\n  empty?: CacheEmptyBehavior;\n  minItemSize?: ByteSize;\n  maxItemSize?: ByteSize;\n  ttl?: Duration;\n}\nexport type ConnectorDriverType = string;\nexport const DriverMemory: ConnectorDriverType = \"memory\";\nexport const DriverRedis: ConnectorDriverType = \"redis\";\nexport const DriverPostgreSQL: ConnectorDriverType = \"postgresql\";\nexport const DriverDynamoDB: ConnectorDriverType = \"dynamodb\";\nexport interface ConnectorConfig {\n  id?: string;\n  driver: TsConnectorDriverType;\n  memory?: MemoryConnectorConfig;\n  redis?: RedisConnectorConfig;\n  dynamodb?: DynamoDBConnectorConfig;\n  postgresql?: PostgreSQLConnectorConfig;\n}\nexport interface MemoryConnectorConfig {\n  maxItems: number /* int */;\n  maxTotalSize: string;\n  emitMetrics?: boolean;\n}\nexport interface MockConnectorConfig {\n  memoryconnectorconfig: MemoryConnectorConfig;\n  getdelay: number /* time in nanoseconds (time.Duration) */;\n  setdelay: number /* time in nanoseconds (time.Duration) */;\n  geterrorrate: number /* float64 */;\n  seterrorrate: number /* float64 */;\n}\nexport interface TLSConfig {\n  enabled: boolean;\n  certFile: string;\n  keyFile: string;\n  caFile?: string;\n  insecureSkipVerify?: boolean;\n}\nexport interface RedisConnectorConfig {\n  addr?: string;\n  username?: string;\n  db?: number /* int */;\n  tls?: TLSConfig;\n  connPoolSize?: number /* int */;\n  uri: string;\n  initTimeout?: Duration;\n  getTimeout?: Duration;\n  setTimeout?: Duration;\n  lockRetryInterval?: Duration;\n}\nexport interface DynamoDBConnectorConfig {\n  table?: string;\n  region?: string;\n  endpoint?: string;\n  auth?: AwsAuthConfig;\n  partitionKeyName?: string;\n  rangeKeyName?: string;\n  reverseIndexName?: string;\n  ttlAttributeName?: string;\n  initTimeout?: Duration;\n  getTimeout?: Duration;\n  setTimeout?: Duration;\n  maxRetries?: number /* int */;\n  statePollInterval?: Duration;\n  lockRetryInterval?: Duration;\n}\nexport interface PostgreSQLConnectorConfig {\n  connectionUri: string;\n  table: string;\n  minConns?: number /* int32 */;\n  maxConns?: number /* int32 */;\n  initTimeout?: Duration;\n  getTimeout?: Duration;\n  setTimeout?: Duration;\n}\nexport interface AwsAuthConfig {\n  mode: 'file' | 'env' | 'secret'; // \"file\", \"env\", \"secret\"\n  credentialsFile: string;\n  profile: string;\n  accessKeyID: string;\n  secretAccessKey: string;\n}\nexport interface ProjectConfig {\n  id: string;\n  auth?: AuthConfig;\n  cors?: CORSConfig;\n  providers?: (ProviderConfig | undefined)[];\n  upstreamDefaults?: UpstreamConfig;\n  upstreams?: (UpstreamConfig | undefined)[];\n  networkDefaults?: NetworkDefaults;\n  networks?: (NetworkConfig | undefined)[];\n  rateLimitBudget?: string;\n  scoreMetricsWindowSize?: Duration;\n  healthCheck?: DeprecatedProjectHealthCheckConfig;\n}\nexport interface NetworkDefaults {\n  rateLimitBudget?: string;\n  failsafe?: (FailsafeConfig | undefined)[];\n  selectionPolicy?: SelectionPolicyConfig;\n  directiveDefaults?: DirectiveDefaultsConfig;\n  evm?: TsEvmNetworkConfigForDefaults;\n}\n/**\n * Define a type alias to avoid recursion\n */\n/**\n * If that fails, try the old format with single failsafe object\n */\nexport interface CORSConfig {\n  allowedOrigins: string[];\n  allowedMethods: string[];\n  allowedHeaders: string[];\n  exposedHeaders: string[];\n  allowCredentials?: boolean;\n  maxAge: number /* int */;\n}\nexport type VendorSettings = { [key: string]: any};\nexport interface ProviderConfig {\n  id?: string;\n  vendor: string;\n  settings?: VendorSettings;\n  onlyNetworks?: string[];\n  ignoreNetworks?: string[];\n  upstreamIdTemplate?: string;\n  overrides?: { [key: string]: UpstreamConfig | undefined};\n}\nexport interface UpstreamConfig {\n  id?: string;\n  type?: TsUpstreamType;\n  group?: string;\n  vendorName?: string;\n  endpoint?: string;\n  evm?: EvmUpstreamConfig;\n  jsonRpc?: JsonRpcUpstreamConfig;\n  ignoreMethods?: string[];\n  allowMethods?: string[];\n  autoIgnoreUnsupportedMethods?: boolean;\n  failsafe?: (FailsafeConfig | undefined)[];\n  rateLimitBudget?: string;\n  rateLimitAutoTune?: RateLimitAutoTuneConfig;\n  routing?: RoutingConfig;\n  shadow?: ShadowUpstreamConfig;\n}\n/**\n * Define a type alias to avoid recursion\n */\n/**\n * If that fails, try the old format with single failsafe object\n */\nexport interface ShadowUpstreamConfig {\n  enabled: boolean;\n  ignoreFields?: { [key: string]: string[]};\n}\nexport interface RoutingConfig {\n  scoreMultipliers: (ScoreMultiplierConfig | undefined)[];\n  scoreLatencyQuantile?: number /* float64 */;\n}\nexport interface ScoreMultiplierConfig {\n  network: string;\n  method: string;\n  overall?: number /* float64 */;\n  errorRate?: number /* float64 */;\n  respLatency?: number /* float64 */;\n  totalRequests?: number /* float64 */;\n  throttledRate?: number /* float64 */;\n  blockHeadLag?: number /* float64 */;\n  finalizationLag?: number /* float64 */;\n}\nexport type Alias = UpstreamConfig;\nexport interface RateLimitAutoTuneConfig {\n  enabled?: boolean;\n  adjustmentPeriod: Duration;\n  errorRateThreshold: number /* float64 */;\n  increaseFactor: number /* float64 */;\n  decreaseFactor: number /* float64 */;\n  minBudget: number /* int */;\n  maxBudget: number /* int */;\n}\nexport interface JsonRpcUpstreamConfig {\n  supportsBatch?: boolean;\n  batchMaxSize?: number /* int */;\n  batchMaxWait?: Duration;\n  enableGzip?: boolean;\n  headers?: { [key: string]: string};\n  proxyPool?: string;\n}\nexport interface EvmUpstreamConfig {\n  chainId: number /* int64 */;\n  nodeType?: EvmNodeType;\n  statePollerInterval?: Duration;\n  statePollerDebounce?: Duration;\n  maxAvailableRecentBlocks?: number /* int64 */;\n  getLogsAutoSplittingRangeThreshold?: number /* int64 */;\n  getLogsMaxAllowedRange?: number /* int64 */;\n  getLogsMaxAllowedAddresses?: number /* int64 */;\n  getLogsMaxAllowedTopics?: number /* int64 */;\n  getLogsSplitOnError?: boolean;\n  skipWhenSyncing?: boolean;\n}\nexport interface FailsafeConfig {\n  matchMethod?: string;\n  matchFinality?: DataFinalityState[];\n  retry?: RetryPolicyConfig;\n  circuitBreaker?: CircuitBreakerPolicyConfig;\n  timeout?: TimeoutPolicyConfig;\n  hedge?: HedgePolicyConfig;\n  consensus?: ConsensusPolicyConfig;\n}\nexport interface RetryPolicyConfig {\n  maxAttempts: number /* int */;\n  delay?: Duration;\n  backoffMaxDelay?: Duration;\n  backoffFactor?: number /* float32 */;\n  jitter?: Duration;\n  emptyResultConfidence?: AvailbilityConfidence;\n  emptyResultIgnore?: string[];\n}\nexport interface CircuitBreakerPolicyConfig {\n  failureThresholdCount: number /* uint */;\n  failureThresholdCapacity: number /* uint */;\n  halfOpenAfter?: Duration;\n  successThresholdCount: number /* uint */;\n  successThresholdCapacity: number /* uint */;\n}\nexport interface TimeoutPolicyConfig {\n  duration?: Duration;\n}\nexport interface HedgePolicyConfig {\n  delay?: Duration;\n  maxCount: number /* int */;\n  quantile?: number /* float64 */;\n  minDelay?: Duration;\n  maxDelay?: Duration;\n}\nexport type ConsensusLowParticipantsBehavior = string;\nexport const ConsensusLowParticipantsBehaviorReturnError: ConsensusLowParticipantsBehavior = \"returnError\";\nexport const ConsensusLowParticipantsBehaviorAcceptMostCommonValidResult: ConsensusLowParticipantsBehavior = \"acceptMostCommonValidResult\";\nexport const ConsensusLowParticipantsBehaviorPreferBlockHeadLeader: ConsensusLowParticipantsBehavior = \"preferBlockHeadLeader\";\nexport const ConsensusLowParticipantsBehaviorOnlyBlockHeadLeader: ConsensusLowParticipantsBehavior = \"onlyBlockHeadLeader\";\nexport type ConsensusDisputeBehavior = string;\nexport const ConsensusDisputeBehaviorReturnError: ConsensusDisputeBehavior = \"returnError\";\nexport const ConsensusDisputeBehaviorAcceptMostCommonValidResult: ConsensusDisputeBehavior = \"acceptMostCommonValidResult\";\nexport const ConsensusDisputeBehaviorPreferBlockHeadLeader: ConsensusDisputeBehavior = \"preferBlockHeadLeader\";\nexport const ConsensusDisputeBehaviorOnlyBlockHeadLeader: ConsensusDisputeBehavior = \"onlyBlockHeadLeader\";\nexport interface ConsensusPolicyConfig {\n  requiredParticipants: number /* int */;\n  agreementThreshold?: number /* int */;\n  disputeBehavior?: ConsensusDisputeBehavior;\n  lowParticipantsBehavior?: ConsensusLowParticipantsBehavior;\n  punishMisbehavior?: PunishMisbehaviorConfig;\n  disputeLogLevel?: string; // \"trace\", \"debug\", \"info\", \"warn\", \"error\"\n  ignoreFields?: { [key: string]: string[]};\n}\nexport interface PunishMisbehaviorConfig {\n  disputeThreshold: number /* uint */;\n  disputeWindow?: Duration;\n  sitOutPenalty?: Duration;\n}\nexport interface RateLimiterConfig {\n  budgets: RateLimitBudgetConfig[];\n}\nexport interface RateLimitBudgetConfig {\n  id: string;\n  rules: RateLimitRuleConfig[];\n}\nexport interface RateLimitRuleConfig {\n  method: string;\n  maxCount: number /* uint */;\n  period: Duration;\n  waitTime: Duration;\n}\nexport interface ProxyPoolConfig {\n  id: string;\n  urls: string[];\n}\nexport interface DeprecatedProjectHealthCheckConfig {\n  scoreMetricsWindowSize: Duration;\n}\nexport interface MethodsConfig {\n  preserveDefaultMethods?: boolean;\n  definitions?: { [key: string]: CacheMethodConfig | undefined};\n}\nexport interface NetworkConfig {\n  architecture: TsNetworkArchitecture;\n  rateLimitBudget?: string;\n  failsafe?: (FailsafeConfig | undefined)[];\n  evm?: EvmNetworkConfig;\n  selectionPolicy?: SelectionPolicyConfig;\n  directiveDefaults?: DirectiveDefaultsConfig;\n  alias?: string;\n  methods?: MethodsConfig;\n}\n/**\n * Define a type alias to avoid recursion\n */\n/**\n * If that fails, try the old format with single failsafe object\n */\nexport interface DirectiveDefaultsConfig {\n  retryEmpty?: boolean;\n  retryPending?: boolean;\n  skipCacheRead?: boolean;\n  useUpstream?: string;\n}\nexport interface EvmNetworkConfig {\n  chainId: number /* int64 */;\n  fallbackFinalityDepth?: number /* int64 */;\n  fallbackStatePollerDebounce?: Duration;\n  integrity?: EvmIntegrityConfig;\n}\nexport interface EvmIntegrityConfig {\n  enforceHighestBlock?: boolean;\n  enforceGetLogsBlockRange?: boolean;\n}\nexport interface SelectionPolicyConfig {\n  evalInterval?: Duration;\n  evalFunction?: SelectionPolicyEvalFunction | undefined;\n  evalPerMethod?: boolean;\n  resampleExcluded?: boolean;\n  resampleInterval?: Duration;\n  resampleCount?: number /* int */;\n}\nexport type AuthType = string;\nexport const AuthTypeSecret: AuthType = \"secret\";\nexport const AuthTypeJwt: AuthType = \"jwt\";\nexport const AuthTypeSiwe: AuthType = \"siwe\";\nexport const AuthTypeNetwork: AuthType = \"network\";\nexport interface AuthConfig {\n  strategies: TsAuthStrategyConfig[];\n}\nexport interface AuthStrategyConfig {\n  ignoreMethods?: string[];\n  allowMethods?: string[];\n  rateLimitBudget?: string;\n  type: TsAuthType;\n  network?: NetworkStrategyConfig;\n  secret?: SecretStrategyConfig;\n  jwt?: JwtStrategyConfig;\n  siwe?: SiweStrategyConfig;\n}\nexport interface SecretStrategyConfig {\n  value: string;\n}\nexport interface JwtStrategyConfig {\n  allowedIssuers: string[];\n  allowedAudiences: string[];\n  allowedAlgorithms: string[];\n  requiredClaims: string[];\n  verificationKeys: { [key: string]: string};\n}\nexport interface SiweStrategyConfig {\n  allowedDomains: string[];\n}\nexport interface NetworkStrategyConfig {\n  allowedIPs: string[];\n  allowedCIDRs: string[];\n  allowLocalhost: boolean;\n  trustedProxies: string[];\n}\nexport type LabelMode = string;\nexport const ErrorLabelModeVerbose: LabelMode = \"verbose\";\nexport const ErrorLabelModeCompact: LabelMode = \"compact\";\nexport interface MetricsConfig {\n  enabled?: boolean;\n  listenV4?: boolean;\n  hostV4?: string;\n  listenV6?: boolean;\n  hostV6?: string;\n  port?: number /* int */;\n  errorLabelMode?: LabelMode;\n  histogramBuckets?: string;\n}\n\n//////////\n// source: data.go\n\nexport type DataFinalityState = number /* int */;\n/**\n * Finalized gets 0 intentionally so that when user has not specified finality,\n * it defaults to finalized, which is safest sane default for caching.\n * This attribute will be calculated based on extracted block number (from request and/or response)\n * and comparing to the upstream (one that returned the response) 'finalized' block (fetch via evm state poller).\n */\nexport const DataFinalityStateFinalized: DataFinalityState = 0;\n/**\n * When we CAN determine the block number, and it's after the upstream 'finalized' block, we consider the data unfinalized.\n */\nexport const DataFinalityStateUnfinalized: DataFinalityState = 1;\n/**\n * Certain methods points are meant to be realtime and updated with every new block (e.g. eth_gasPrice).\n * These can be cached with short TTLs to improve performance.\n */\nexport const DataFinalityStateRealtime: DataFinalityState = 2;\n/**\n * When we CANNOT determine the block number (e.g some trace by hash calls), we consider the data unknown.\n * Most often it is safe to cache this data for longer as they're access when block hash is provided directly.\n */\nexport const DataFinalityStateUnknown: DataFinalityState = 3;\nexport type CacheEmptyBehavior = number /* int */;\nexport const CacheEmptyBehaviorIgnore: CacheEmptyBehavior = 0;\nexport const CacheEmptyBehaviorAllow: CacheEmptyBehavior = 1;\nexport const CacheEmptyBehaviorOnly: CacheEmptyBehavior = 2;\n\n//////////\n// source: network.go\n\nexport type NetworkArchitecture = string;\nexport const ArchitectureEvm: NetworkArchitecture = \"evm\";\nexport type Network = any;\nexport type QuantileTracker = any;\nexport type TrackedMetrics = any;\n\n//////////\n// source: upstream.go\n\nexport type Scope = string;\n/**\n * Policies must be created with a \"network\" in mind,\n * assuming there will be many upstreams e.g. Retry might endup using a different upstream\n */\nexport const ScopeNetwork: Scope = \"network\";\n/**\n * Policies must be created with one only \"upstream\" in mind\n * e.g. Retry with be towards the same upstream\n */\nexport const ScopeUpstream: Scope = \"upstream\";\nexport type UpstreamType = string;\nexport type Upstream = any;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACkBO,IAAM,kBAAgC;AAOtC,IAAM,qBAAkC;AACxC,IAAM,kBAA+B;AACrC,IAAM,qBAAkC;AAExC,IAAM,yBAA0C;AAChD,IAAM,yBAA0C;AAChD,IAAM,4BAA6C;AAqWnD,IAAM,8CAAgF;AACtF,IAAM,8DAAgG;AACtG,IAAM,wDAA0F;AAChG,IAAM,sDAAwF;AAE9F,IAAM,sCAAgE;AACtE,IAAM,sDAAgF;AACtF,IAAM,gDAA0E;AAChF,IAAM,8CAAwE;AAgF9E,IAAM,iBAA2B;AACjC,IAAM,cAAwB;AAC9B,IAAM,eAAyB;AAC/B,IAAM,kBAA4B;AAyDlC,IAAM,6BAAgD;AAItD,IAAM,+BAAkD;AAKxD,IAAM,4BAA+C;AAKrD,IAAM,2BAA8C;AAEpD,IAAM,2BAA+C;AACrD,IAAM,0BAA8C;AACpD,IAAM,yBAA6C;AAMnD,IAAM,kBAAuC;AAa7C,IAAM,eAAsB;AAK5B,IAAM,gBAAuB;;;AD7c7B,IAAM,eAAe,CAC1B,QACW;AACX,SAAO;AACT;",
  "names": []
}
