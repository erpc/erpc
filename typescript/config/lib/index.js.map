{
  "version": 3,
  "sources": ["../src/index.ts", "../src/generated.ts"],
  "sourcesContent": ["export type {\n  // Tygo generic replacement\n  LogLevel,\n  Duration,\n  ByteSize,\n  NetworkArchitecture,\n  ConnectorDriverType,\n  ConnectorConfig,\n  UpstreamType,\n  // Policy evaluation\n  PolicyEvalUpstreamMetrics,\n  PolicyEvalUpstream,\n  SelectionPolicyEvalFunction,\n  EvmNetworkConfigForDefaults,\n} from \"./types\";\nexport {\n  // Data finality const exports\n  DataFinalityStateUnfinalized,\n  DataFinalityStateFinalized,\n  DataFinalityStateRealtime,\n  DataFinalityStateUnknown,\n  // Scope exports\n  ScopeNetwork,\n  ScopeUpstream,\n  // Cache behavior exports\n  CacheEmptyBehaviorIgnore,\n  CacheEmptyBehaviorAllow,\n  CacheEmptyBehaviorOnly,\n  // Evm node type\n  EvmNodeTypeFull,\n  EvmNodeTypeArchive,\n  EvmNodeTypeUnknown,\n  // Evm syncing type\n  EvmSyncingStateUnknown,\n  EvmSyncingStateSyncing,\n  EvmSyncingStateNotSyncing,\n  // Architecture export\n  ArchitectureEvm,\n  // Upstream types const exprots\n  UpstreamTypeEvm,\n  // Auth types\n  AuthTypeSecret,\n  AuthTypeJwt,\n  AuthTypeSiwe,\n  AuthTypeNetwork,\n  // Consensus related\n  ConsensusLowParticipantsBehaviorReturnError,\n  ConsensusLowParticipantsBehaviorAcceptMostCommonValidResult,\n  ConsensusLowParticipantsBehaviorPreferBlockHeadLeader,\n  ConsensusLowParticipantsBehaviorOnlyBlockHeadLeader,\n  ConsensusDisputeBehaviorReturnError,\n  ConsensusDisputeBehaviorAcceptMostCommonValidResult,\n  ConsensusDisputeBehaviorPreferBlockHeadLeader,\n  ConsensusDisputeBehaviorOnlyBlockHeadLeader,\n} from \"./generated\";\nexport type {\n  Config,\n  ProjectConfig,\n  HealthCheckConfig,\n  // Provider related\n  ProviderConfig,\n  VendorSettings,\n  // Upstream related\n  UpstreamConfig,\n  EvmUpstreamConfig,\n  UpstreamIntegrityConfig,\n  UpstreamIntegrityEthGetBlockReceiptsConfig,\n  RoutingConfig,\n  ScoreMultiplierConfig,\n  RateLimitAutoTuneConfig,\n  JsonRpcUpstreamConfig,\n  // Failsafe related\n  FailsafeConfig,\n  RetryPolicyConfig,\n  CircuitBreakerPolicyConfig,\n  HedgePolicyConfig,\n  TimeoutPolicyConfig,\n  ConsensusPolicyConfig,\n  // Network related\n  NetworkConfig,\n  EvmNetworkConfig,\n  EvmIntegrityConfig,\n  SelectionPolicyConfig,\n  DirectiveDefaultsConfig,\n  // DB related\n  DatabaseConfig,\n  CacheConfig,\n  DataFinalityState,\n  CacheEmptyBehavior,\n  CachePolicyConfig,\n  MemoryConnectorConfig,\n  RedisConnectorConfig,\n  DynamoDBConnectorConfig,\n  AwsAuthConfig,\n  PostgreSQLConnectorConfig,\n  // Auth related\n  AuthStrategyConfig,\n  SecretStrategyConfig,\n  JwtStrategyConfig,\n  SiweStrategyConfig,\n  NetworkStrategyConfig,\n  // Rate limits related\n  RateLimiterConfig,\n  RateLimitBudgetConfig,\n  RateLimitRuleConfig,\n  // Server config related\n  ServerConfig,\n  CORSConfig,\n  MetricsConfig,\n  AdminConfig,\n  AliasingConfig,\n  AliasingRuleConfig,\n  TLSConfig,\n  // Proxy pools related\n  ProxyPoolConfig,\n} from \"./generated\";\n\nimport type { Config } from './generated'\n\nexport const createConfig = (\n  cfg: Config\n): Config => {\n  return cfg;\n};\n", "// Code generated by tygo. DO NOT EDIT.\nimport type { \n  LogLevel,\n  Duration,\n  ByteSize,\n  ConnectorDriverType as TsConnectorDriverType,\n  ConnectorConfig as TsConnectorConfig,\n  UpstreamType as TsUpstreamType,\n  NetworkArchitecture as TsNetworkArchitecture,\n  AuthType as TsAuthType,\n  AuthStrategyConfig as TsAuthStrategyConfig,\n  EvmNetworkConfigForDefaults as TsEvmNetworkConfigForDefaults,\n  SelectionPolicyEvalFunction\n} from \"./types\"\n\n//////////\n// source: architecture_evm.go\n\nexport const UpstreamTypeEvm: UpstreamType = \"evm\";\nexport type EvmUpstream = \n    Upstream;\nexport type AvailbilityConfidence = number /* int */;\nexport const AvailbilityConfidenceBlockHead: AvailbilityConfidence = 1;\nexport const AvailbilityConfidenceFinalized: AvailbilityConfidence = 2;\nexport type EvmNodeType = string;\nexport const EvmNodeTypeUnknown: EvmNodeType = \"unknown\";\nexport const EvmNodeTypeFull: EvmNodeType = \"full\";\nexport const EvmNodeTypeArchive: EvmNodeType = \"archive\";\nexport type EvmSyncingState = number /* int */;\nexport const EvmSyncingStateUnknown: EvmSyncingState = 0;\nexport const EvmSyncingStateSyncing: EvmSyncingState = 1;\nexport const EvmSyncingStateNotSyncing: EvmSyncingState = 2;\nexport type EvmStatePoller = any;\n\n//////////\n// source: cache_dal.go\n\nexport type CacheDAL = any;\n\n//////////\n// source: cache_mock.go\n\nexport interface MockCacheDal {\n  mock: any /* mock.Mock */;\n}\n\n//////////\n// source: config.go\n\n/**\n * Config represents the configuration of the application.\n */\nexport interface Config {\n  logLevel?: LogLevel;\n  clusterKey?: string;\n  server?: ServerConfig;\n  healthCheck?: HealthCheckConfig;\n  admin?: AdminConfig;\n  database?: DatabaseConfig;\n  projects?: (ProjectConfig | undefined)[];\n  rateLimiters?: RateLimiterConfig;\n  metrics?: MetricsConfig;\n  proxyPools?: (ProxyPoolConfig | undefined)[];\n  tracing?: TracingConfig;\n}\nexport interface ServerConfig {\n  listenV4?: boolean;\n  httpHostV4?: string;\n  listenV6?: boolean;\n  httpHostV6?: string;\n  httpPort?: number /* int */; // Deprecated: use HttpPortV4\n  httpPortV4?: number /* int */;\n  httpPortV6?: number /* int */;\n  maxTimeout?: Duration;\n  readTimeout?: Duration;\n  writeTimeout?: Duration;\n  enableGzip?: boolean;\n  tls?: TLSConfig;\n  aliasing?: AliasingConfig;\n  waitBeforeShutdown?: Duration;\n  waitAfterShutdown?: Duration;\n  includeErrorDetails?: boolean;\n  trustedIPForwarders?: string[];\n  trustedIPHeaders?: string[];\n}\nexport interface HealthCheckConfig {\n  mode?: HealthCheckMode;\n  auth?: AuthConfig;\n  defaultEval?: string;\n}\nexport type HealthCheckMode = string;\nexport const HealthCheckModeSimple: HealthCheckMode = \"simple\";\nexport const HealthCheckModeNetworks: HealthCheckMode = \"networks\";\nexport const HealthCheckModeVerbose: HealthCheckMode = \"verbose\";\nexport const EvalAnyInitializedUpstreams = \"any:initializedUpstreams\";\nexport const EvalAnyErrorRateBelow90 = \"any:errorRateBelow90\";\nexport const EvalAllErrorRateBelow90 = \"all:errorRateBelow90\";\nexport const EvalAnyErrorRateBelow100 = \"any:errorRateBelow100\";\nexport const EvalAllErrorRateBelow100 = \"all:errorRateBelow100\";\nexport const EvalEvmAnyChainId = \"any:evm:eth_chainId\";\nexport const EvalEvmAllChainId = \"all:evm:eth_chainId\";\nexport const EvalAllActiveUpstreams = \"all:activeUpstreams\";\nexport type TracingProtocol = string;\nexport const TracingProtocolHttp: TracingProtocol = \"http\";\nexport const TracingProtocolGrpc: TracingProtocol = \"grpc\";\nexport interface TracingConfig {\n  enabled?: boolean;\n  endpoint?: string;\n  protocol?: TracingProtocol;\n  sampleRate?: number /* float64 */;\n  detailed?: boolean;\n  tls?: TLSConfig;\n}\nexport interface AdminConfig {\n  auth?: AuthConfig;\n  cors?: CORSConfig;\n}\nexport interface AliasingConfig {\n  rules: (AliasingRuleConfig | undefined)[];\n}\nexport interface AliasingRuleConfig {\n  matchDomain: string;\n  serveProject: string;\n  serveArchitecture: string;\n  serveChain: string;\n}\nexport interface DatabaseConfig {\n  evmJsonRpcCache?: CacheConfig;\n  sharedState?: SharedStateConfig;\n}\nexport interface SharedStateConfig {\n  clusterKey?: string;\n  connector?: ConnectorConfig;\n  fallbackTimeout?: Duration;\n  lockTtl?: Duration;\n}\nexport interface CacheConfig {\n  connectors?: TsConnectorConfig[];\n  policies?: (CachePolicyConfig | undefined)[];\n  compression?: CompressionConfig;\n}\nexport interface CompressionConfig {\n  enabled?: boolean;\n  algorithm?: string; // \"zstd\" for now, can be extended\n  zstdLevel?: string; // \"fastest\", \"default\", \"better\", \"best\"\n  threshold?: number /* int */; // Minimum size in bytes to compress\n}\nexport interface CacheMethodConfig {\n  reqRefs: any[][];\n  respRefs: any[][];\n  finalized: boolean;\n  realtime: boolean;\n  stateful?: boolean;\n}\nexport interface CachePolicyConfig {\n  connector: string;\n  network?: string;\n  method?: string;\n  params?: any[];\n  finality?: DataFinalityState;\n  empty?: CacheEmptyBehavior;\n  appliesTo?: 'get' | 'set' | 'both';\n  minItemSize?: ByteSize;\n  maxItemSize?: ByteSize;\n  ttl?: Duration;\n}\nexport type ConnectorDriverType = string;\nexport const DriverMemory: ConnectorDriverType = \"memory\";\nexport const DriverRedis: ConnectorDriverType = \"redis\";\nexport const DriverPostgreSQL: ConnectorDriverType = \"postgresql\";\nexport const DriverDynamoDB: ConnectorDriverType = \"dynamodb\";\nexport const DriverGrpc: ConnectorDriverType = \"grpc\";\nexport interface ConnectorConfig {\n  id?: string;\n  driver: TsConnectorDriverType;\n  memory?: MemoryConnectorConfig;\n  redis?: RedisConnectorConfig;\n  dynamodb?: DynamoDBConnectorConfig;\n  postgresql?: PostgreSQLConnectorConfig;\n  grpc?: GrpcConnectorConfig;\n}\nexport interface GrpcConnectorConfig {\n  bootstrap?: string;\n  servers?: string[];\n  headers?: { [key: string]: string};\n}\nexport interface MemoryConnectorConfig {\n  maxItems: number /* int */;\n  maxTotalSize: string;\n  emitMetrics?: boolean;\n}\nexport interface MockConnectorConfig {\n  memoryconnectorconfig: MemoryConnectorConfig;\n  getdelay: number /* time in nanoseconds (time.Duration) */;\n  setdelay: number /* time in nanoseconds (time.Duration) */;\n  geterrorrate: number /* float64 */;\n  seterrorrate: number /* float64 */;\n}\nexport interface TLSConfig {\n  enabled: boolean;\n  certFile: string;\n  keyFile: string;\n  caFile?: string;\n  insecureSkipVerify?: boolean;\n}\nexport interface RedisConnectorConfig {\n  addr?: string;\n  username?: string;\n  db?: number /* int */;\n  tls?: TLSConfig;\n  connPoolSize?: number /* int */;\n  uri: string;\n  initTimeout?: Duration;\n  getTimeout?: Duration;\n  setTimeout?: Duration;\n  lockRetryInterval?: Duration;\n}\nexport interface DynamoDBConnectorConfig {\n  table?: string;\n  region?: string;\n  endpoint?: string;\n  auth?: AwsAuthConfig;\n  partitionKeyName?: string;\n  rangeKeyName?: string;\n  reverseIndexName?: string;\n  ttlAttributeName?: string;\n  initTimeout?: Duration;\n  getTimeout?: Duration;\n  setTimeout?: Duration;\n  maxRetries?: number /* int */;\n  statePollInterval?: Duration;\n  lockRetryInterval?: Duration;\n}\nexport interface PostgreSQLConnectorConfig {\n  connectionUri: string;\n  table: string;\n  minConns?: number /* int32 */;\n  maxConns?: number /* int32 */;\n  initTimeout?: Duration;\n  getTimeout?: Duration;\n  setTimeout?: Duration;\n}\nexport interface AwsAuthConfig {\n  mode: 'file' | 'env' | 'secret'; // \"file\", \"env\", \"secret\"\n  credentialsFile: string;\n  profile: string;\n  accessKeyID: string;\n  secretAccessKey: string;\n}\nexport interface ProjectConfig {\n  id: string;\n  auth?: AuthConfig;\n  cors?: CORSConfig;\n  providers?: (ProviderConfig | undefined)[];\n  upstreamDefaults?: UpstreamConfig;\n  upstreams?: (UpstreamConfig | undefined)[];\n  networkDefaults?: NetworkDefaults;\n  networks?: (NetworkConfig | undefined)[];\n  rateLimitBudget?: string;\n  scoreMetricsWindowSize?: Duration;\n  scoreRefreshInterval?: Duration;\n  healthCheck?: DeprecatedProjectHealthCheckConfig;\n}\nexport interface NetworkDefaults {\n  rateLimitBudget?: string;\n  failsafe?: (FailsafeConfig | undefined)[];\n  selectionPolicy?: SelectionPolicyConfig;\n  directiveDefaults?: DirectiveDefaultsConfig;\n  evm?: TsEvmNetworkConfigForDefaults;\n}\nexport interface CORSConfig {\n  allowedOrigins: string[];\n  allowedMethods: string[];\n  allowedHeaders: string[];\n  exposedHeaders: string[];\n  allowCredentials?: boolean;\n  maxAge: number /* int */;\n}\nexport type VendorSettings = { [key: string]: any};\nexport interface ProviderConfig {\n  id?: string;\n  vendor: string;\n  settings?: VendorSettings;\n  onlyNetworks?: string[];\n  ignoreNetworks?: string[];\n  upstreamIdTemplate?: string;\n  overrides?: { [key: string]: UpstreamConfig | undefined};\n}\nexport interface UpstreamConfig {\n  id?: string;\n  type?: TsUpstreamType;\n  group?: string;\n  vendorName?: string;\n  endpoint?: string;\n  evm?: EvmUpstreamConfig;\n  jsonRpc?: JsonRpcUpstreamConfig;\n  ignoreMethods?: string[];\n  allowMethods?: string[];\n  autoIgnoreUnsupportedMethods?: boolean;\n  failsafe?: (FailsafeConfig | undefined)[];\n  rateLimitBudget?: string;\n  rateLimitAutoTune?: RateLimitAutoTuneConfig;\n  routing?: RoutingConfig;\n  shadow?: ShadowUpstreamConfig;\n}\nexport interface ShadowUpstreamConfig {\n  enabled: boolean;\n  ignoreFields?: { [key: string]: string[]};\n}\nexport interface UpstreamIntegrityConfig {\n  eth_getBlockReceipts?: UpstreamIntegrityEthGetBlockReceiptsConfig;\n}\nexport interface UpstreamIntegrityEthGetBlockReceiptsConfig {\n  enabled?: boolean;\n  checkLogIndexStrictIncrements?: boolean;\n  checkLogsBloom?: boolean;\n}\nexport interface RoutingConfig {\n  scoreMultipliers: (ScoreMultiplierConfig | undefined)[];\n  scoreLatencyQuantile?: number /* float64 */;\n}\nexport interface ScoreMultiplierConfig {\n  network: string;\n  method: string;\n  overall?: number /* float64 */;\n  errorRate?: number /* float64 */;\n  respLatency?: number /* float64 */;\n  totalRequests?: number /* float64 */;\n  throttledRate?: number /* float64 */;\n  blockHeadLag?: number /* float64 */;\n  finalizationLag?: number /* float64 */;\n  misbehaviors?: number /* float64 */;\n}\nexport type Alias = UpstreamConfig;\nexport interface RateLimitAutoTuneConfig {\n  enabled?: boolean;\n  adjustmentPeriod: Duration;\n  errorRateThreshold: number /* float64 */;\n  increaseFactor: number /* float64 */;\n  decreaseFactor: number /* float64 */;\n  minBudget: number /* int */;\n  maxBudget: number /* int */;\n}\nexport interface JsonRpcUpstreamConfig {\n  supportsBatch?: boolean;\n  batchMaxSize?: number /* int */;\n  batchMaxWait?: Duration;\n  enableGzip?: boolean;\n  headers?: { [key: string]: string};\n  proxyPool?: string;\n}\nexport interface EvmUpstreamConfig {\n  chainId: number /* int64 */;\n  nodeType?: EvmNodeType;\n  statePollerInterval?: Duration;\n  statePollerDebounce?: Duration;\n  maxAvailableRecentBlocks?: number /* int64 */;\n  getLogsAutoSplittingRangeThreshold?: number /* int64 */;\n  skipWhenSyncing?: boolean;\n  integrity?: UpstreamIntegrityConfig;\n}\nexport interface FailsafeConfig {\n  matchMethod?: string;\n  matchFinality?: DataFinalityState[];\n  retry?: RetryPolicyConfig;\n  circuitBreaker?: CircuitBreakerPolicyConfig;\n  timeout?: TimeoutPolicyConfig;\n  hedge?: HedgePolicyConfig;\n  consensus?: ConsensusPolicyConfig;\n}\nexport interface RetryPolicyConfig {\n  maxAttempts: number /* int */;\n  delay?: Duration;\n  backoffMaxDelay?: Duration;\n  backoffFactor?: number /* float32 */;\n  jitter?: Duration;\n  emptyResultConfidence?: AvailbilityConfidence;\n  emptyResultIgnore?: string[];\n  /**\n   * EmptyResultMaxAttempts limits total attempts when retries are triggered due to empty responses.\n   */\n  emptyResultMaxAttempts?: number /* int */;\n}\nexport interface CircuitBreakerPolicyConfig {\n  failureThresholdCount: number /* uint */;\n  failureThresholdCapacity: number /* uint */;\n  halfOpenAfter?: Duration;\n  successThresholdCount: number /* uint */;\n  successThresholdCapacity: number /* uint */;\n}\nexport interface TimeoutPolicyConfig {\n  duration?: Duration;\n}\nexport interface HedgePolicyConfig {\n  delay?: Duration;\n  maxCount: number /* int */;\n  quantile?: number /* float64 */;\n  minDelay?: Duration;\n  maxDelay?: Duration;\n}\nexport type ConsensusLowParticipantsBehavior = string;\nexport const ConsensusLowParticipantsBehaviorReturnError: ConsensusLowParticipantsBehavior = \"returnError\";\nexport const ConsensusLowParticipantsBehaviorAcceptMostCommonValidResult: ConsensusLowParticipantsBehavior = \"acceptMostCommonValidResult\";\nexport const ConsensusLowParticipantsBehaviorPreferBlockHeadLeader: ConsensusLowParticipantsBehavior = \"preferBlockHeadLeader\";\nexport const ConsensusLowParticipantsBehaviorOnlyBlockHeadLeader: ConsensusLowParticipantsBehavior = \"onlyBlockHeadLeader\";\nexport type ConsensusDisputeBehavior = string;\nexport const ConsensusDisputeBehaviorReturnError: ConsensusDisputeBehavior = \"returnError\";\nexport const ConsensusDisputeBehaviorAcceptMostCommonValidResult: ConsensusDisputeBehavior = \"acceptMostCommonValidResult\";\nexport const ConsensusDisputeBehaviorPreferBlockHeadLeader: ConsensusDisputeBehavior = \"preferBlockHeadLeader\";\nexport const ConsensusDisputeBehaviorOnlyBlockHeadLeader: ConsensusDisputeBehavior = \"onlyBlockHeadLeader\";\nexport interface ConsensusPolicyConfig {\n  maxParticipants: number /* int */;\n  agreementThreshold?: number /* int */;\n  disputeBehavior?: ConsensusDisputeBehavior;\n  lowParticipantsBehavior?: ConsensusLowParticipantsBehavior;\n  punishMisbehavior?: PunishMisbehaviorConfig;\n  disputeLogLevel?: string; // \"trace\", \"debug\", \"info\", \"warn\", \"error\"\n  ignoreFields?: { [key: string]: string[]};\n  preferNonEmpty?: boolean;\n  preferLargerResponses?: boolean;\n  misbehaviorsDestination?: MisbehaviorsDestinationConfig;\n}\nexport type MisbehaviorsDestinationType = string;\nexport const MisbehaviorsDestinationTypeFile: MisbehaviorsDestinationType = \"file\";\nexport const MisbehaviorsDestinationTypeS3: MisbehaviorsDestinationType = \"s3\";\nexport interface MisbehaviorsDestinationConfig {\n  /**\n   * Type of destination: \"file\" or \"s3\"\n   */\n  type: 'file' | 's3';\n  /**\n   * Path for file destination, or S3 URI (s3://bucket/prefix/) for S3 destination\n   */\n  path: string;\n  /**\n   * Pattern for generating file names. Supports placeholders:\n   * {dateByHour} - formatted as 2006-01-02-15\n   * {dateByDay} - formatted as 2006-01-02\n   * {method} - the RPC method name\n   * {networkId} - the network ID with : replaced by _\n   * {instanceId} - unique instance identifier\n   */\n  filePattern?: string;\n  /**\n   * S3-specific settings for bulk flushing\n   */\n  s3?: S3FlushConfig;\n}\nexport interface S3FlushConfig {\n  /**\n   * Maximum number of records to buffer before flushing (default: 100)\n   */\n  maxRecords?: number /* int */;\n  /**\n   * Maximum size in bytes to buffer before flushing (default: 1MB)\n   */\n  maxSize?: number /* int64 */;\n  /**\n   * Maximum time to wait before flushing buffered records (default: 60s)\n   */\n  flushInterval?: Duration;\n  /**\n   * AWS region for S3 bucket (defaults to AWS_REGION env var)\n   */\n  region?: string;\n  /**\n   * AWS credentials config (optional). If not specified, uses standard AWS credential chain:\n   * 1. Environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)\n   * 2. IAM role (for EC2/ECS/EKS)\n   * 3. Shared credentials file (~/.aws/credentials)\n   * Supported modes: \"env\", \"file\", \"secret\"\n   */\n  credentials?: AwsAuthConfig;\n  /**\n   * Content type for uploaded files (default: \"application/jsonl\")\n   */\n  contentType?: string;\n}\nexport interface PunishMisbehaviorConfig {\n  disputeThreshold: number /* uint */;\n  disputeWindow?: Duration;\n  sitOutPenalty?: Duration;\n}\nexport interface RateLimiterConfig {\n  store?: RateLimitStoreConfig;\n  budgets: RateLimitBudgetConfig[];\n}\nexport interface RateLimitBudgetConfig {\n  id: string;\n  rules: RateLimitRuleConfig[];\n}\nexport interface RateLimitRuleConfig {\n  method: string;\n  maxCount: number /* uint32 */;\n  /**\n   * Period is the canonical period selector. Supported: second, minute, hour, day, week, month, year\n   */\n  period: RateLimitPeriod;\n  waitTime?: Duration;\n  perIP?: boolean;\n  perUser?: boolean;\n  perNetwork?: boolean;\n}\n/**\n * RateLimitPeriod enumerates supported periods for rate limiting.\n * It is an int enum to enable strong typing in TypeScript generation, while\n * marshaling to JSON/YAML as human-readable strings like \"second\", \"minute\", etc.\n */\nexport type RateLimitPeriod = number /* int */;\nexport const RateLimitPeriodSecond: RateLimitPeriod = 0;\nexport const RateLimitPeriodMinute: RateLimitPeriod = 1;\nexport const RateLimitPeriodHour: RateLimitPeriod = 2;\nexport const RateLimitPeriodDay: RateLimitPeriod = 3;\nexport const RateLimitPeriodWeek: RateLimitPeriod = 4;\nexport const RateLimitPeriodMonth: RateLimitPeriod = 5;\nexport const RateLimitPeriodYear: RateLimitPeriod = 6;\nexport interface ProxyPoolConfig {\n  id: string;\n  urls: string[];\n}\nexport interface DeprecatedProjectHealthCheckConfig {\n  scoreMetricsWindowSize: Duration;\n}\nexport interface MethodsConfig {\n  preserveDefaultMethods?: boolean;\n  definitions?: { [key: string]: CacheMethodConfig | undefined};\n}\nexport interface NetworkConfig {\n  architecture: TsNetworkArchitecture;\n  rateLimitBudget?: string;\n  failsafe?: (FailsafeConfig | undefined)[];\n  evm?: EvmNetworkConfig;\n  selectionPolicy?: SelectionPolicyConfig;\n  directiveDefaults?: DirectiveDefaultsConfig;\n  alias?: string;\n  methods?: MethodsConfig;\n}\nexport interface DirectiveDefaultsConfig {\n  retryEmpty?: boolean;\n  retryPending?: boolean;\n  skipCacheRead?: boolean;\n  useUpstream?: string;\n}\nexport interface EvmNetworkConfig {\n  chainId: number /* int64 */;\n  fallbackFinalityDepth?: number /* int64 */;\n  fallbackStatePollerDebounce?: Duration;\n  integrity?: EvmIntegrityConfig;\n  getLogsMaxAllowedRange?: number /* int64 */;\n  getLogsMaxAllowedAddresses?: number /* int64 */;\n  getLogsMaxAllowedTopics?: number /* int64 */;\n  getLogsSplitOnError?: boolean;\n  getLogsSplitConcurrency?: number /* int */;\n}\nexport interface EvmIntegrityConfig {\n  enforceHighestBlock?: boolean;\n  enforceGetLogsBlockRange?: boolean;\n  enforceNonNullTaggedBlocks?: boolean;\n}\nexport interface SelectionPolicyConfig {\n  evalInterval?: Duration;\n  evalFunction?: SelectionPolicyEvalFunction | undefined;\n  evalPerMethod?: boolean;\n  resampleExcluded?: boolean;\n  resampleInterval?: Duration;\n  resampleCount?: number /* int */;\n}\nexport type AuthType = string;\nexport const AuthTypeSecret: AuthType = \"secret\";\nexport const AuthTypeDatabase: AuthType = \"database\";\nexport const AuthTypeJwt: AuthType = \"jwt\";\nexport const AuthTypeSiwe: AuthType = \"siwe\";\nexport const AuthTypeNetwork: AuthType = \"network\";\nexport interface AuthConfig {\n  strategies: TsAuthStrategyConfig[];\n}\nexport interface AuthStrategyConfig {\n  ignoreMethods?: string[];\n  allowMethods?: string[];\n  rateLimitBudget?: string;\n  type: TsAuthType;\n  network?: NetworkStrategyConfig;\n  secret?: SecretStrategyConfig;\n  database?: DatabaseStrategyConfig;\n  jwt?: JwtStrategyConfig;\n  siwe?: SiweStrategyConfig;\n}\nexport interface SecretStrategyConfig {\n  id: string;\n  value: string;\n  /**\n   * RateLimitBudget, if set, is applied to the authenticated user from this strategy\n   */\n  rateLimitBudget?: string;\n}\nexport interface DatabaseStrategyConfig {\n  connector?: ConnectorConfig;\n  cache?: DatabaseStrategyCacheConfig;\n}\nexport interface DatabaseStrategyCacheConfig {\n  ttl?: number /* time in nanoseconds (time.Duration) */;\n  maxSize?: number /* int64 */;\n  maxCost?: number /* int64 */;\n  numCounters?: number /* int64 */;\n}\nexport interface JwtStrategyConfig {\n  allowedIssuers: string[];\n  allowedAudiences: string[];\n  allowedAlgorithms: string[];\n  requiredClaims: string[];\n  verificationKeys: { [key: string]: string};\n  /**\n   * RateLimitBudgetClaimName is the JWT claim name that, if present,\n   * will be used to set the per-user RateLimitBudget override.\n   * Defaults to \"rlm\".\n   */\n  rateLimitBudgetClaimName?: string;\n}\nexport interface SiweStrategyConfig {\n  allowedDomains: string[];\n  /**\n   * RateLimitBudget, if set, is applied to the authenticated user\n   */\n  rateLimitBudget?: string;\n}\nexport interface NetworkStrategyConfig {\n  allowedIPs: string[];\n  allowedCIDRs: string[];\n  allowLocalhost: boolean;\n  trustedProxies: string[];\n  /**\n   * RateLimitBudget, if set, is applied to the authenticated user (client IP)\n   */\n  rateLimitBudget?: string;\n}\nexport type LabelMode = string;\nexport const ErrorLabelModeVerbose: LabelMode = \"verbose\";\nexport const ErrorLabelModeCompact: LabelMode = \"compact\";\nexport interface MetricsConfig {\n  enabled?: boolean;\n  listenV4?: boolean;\n  hostV4?: string;\n  listenV6?: boolean;\n  hostV6?: string;\n  port?: number /* int */;\n  errorLabelMode?: LabelMode;\n  histogramBuckets?: string;\n}\n/**\n * RateLimitStoreConfig defines where rate limit counters are stored\n */\nexport interface RateLimitStoreConfig {\n  driver: string; // \"redis\" | \"memory\"\n  redis?: RedisConnectorConfig;\n  cacheKeyPrefix?: string;\n  nearLimitRatio?: number /* float32 */;\n}\n\n//////////\n// source: data.go\n\nexport type DataFinalityState = number /* int */;\n/**\n * Finalized gets 0 intentionally so that when user has not specified finality,\n * it defaults to finalized, which is safest sane default for caching.\n * This attribute will be calculated based on extracted block number (from request and/or response)\n * and comparing to the upstream (one that returned the response) 'finalized' block (fetch via evm state poller).\n */\nexport const DataFinalityStateFinalized: DataFinalityState = 0;\n/**\n * When we CAN determine the block number, and it's after the upstream 'finalized' block, we consider the data unfinalized.\n */\nexport const DataFinalityStateUnfinalized: DataFinalityState = 1;\n/**\n * Certain methods points are meant to be realtime and updated with every new block (e.g. eth_gasPrice).\n * These can be cached with short TTLs to improve performance.\n */\nexport const DataFinalityStateRealtime: DataFinalityState = 2;\n/**\n * When we CANNOT determine the block number (e.g some trace by hash calls), we consider the data unknown.\n * Most often it is safe to cache this data for longer as they're access when block hash is provided directly.\n */\nexport const DataFinalityStateUnknown: DataFinalityState = 3;\nexport type CacheEmptyBehavior = number /* int */;\nexport const CacheEmptyBehaviorIgnore: CacheEmptyBehavior = 0;\nexport const CacheEmptyBehaviorAllow: CacheEmptyBehavior = 1;\nexport const CacheEmptyBehaviorOnly: CacheEmptyBehavior = 2;\n/**\n * CachePolicyAppliesTo controls whether a cache policy applies to get, set, or both operations.\n */\nexport type CachePolicyAppliesTo = string;\nexport const CachePolicyAppliesToBoth: CachePolicyAppliesTo = \"both\";\nexport const CachePolicyAppliesToGet: CachePolicyAppliesTo = \"get\";\nexport const CachePolicyAppliesToSet: CachePolicyAppliesTo = \"set\";\n\n//////////\n// source: error_extractor.go\n\n/**\n * JsonRpcErrorExtractor allows callers to inject architecture-specific\n * JSON-RPC error normalization logic into HTTP clients without creating\n * package import cycles.\n */\nexport type JsonRpcErrorExtractor = any;\n/**\n * JsonRpcErrorExtractorFunc is an adapter to allow normal functions to be used\n * as JsonRpcErrorExtractor implementations.\n * Similar to http.HandlerFunc style adapters.\n */\nexport type JsonRpcErrorExtractorFunc = any;\n\n//////////\n// source: network.go\n\nexport type NetworkArchitecture = string;\nexport const ArchitectureEvm: NetworkArchitecture = \"evm\";\nexport type Network = any;\nexport type QuantileTracker = any;\nexport type TrackedMetrics = any;\n\n//////////\n// source: upstream.go\n\nexport type Scope = string;\n/**\n * Policies must be created with a \"network\" in mind,\n * assuming there will be many upstreams e.g. Retry might endup using a different upstream\n */\nexport const ScopeNetwork: Scope = \"network\";\n/**\n * Policies must be created with one only \"upstream\" in mind\n * e.g. Retry with be towards the same upstream\n */\nexport const ScopeUpstream: Scope = \"upstream\";\nexport type UpstreamType = string;\n/**\n * HealthTracker is an interface for tracking upstream health metrics\n */\nexport type HealthTracker = any;\nexport type Upstream = any;\n\n//////////\n// source: user.go\n\nexport interface User {\n  id: string;\n  ratelimitbudget: string;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACkBO,IAAM,kBAAgC;AAOtC,IAAM,qBAAkC;AACxC,IAAM,kBAA+B;AACrC,IAAM,qBAAkC;AAExC,IAAM,yBAA0C;AAChD,IAAM,yBAA0C;AAChD,IAAM,4BAA6C;AAkXnD,IAAM,8CAAgF;AACtF,IAAM,8DAAgG;AACtG,IAAM,wDAA0F;AAChG,IAAM,sDAAwF;AAE9F,IAAM,sCAAgE;AACtE,IAAM,sDAAgF;AACtF,IAAM,gDAA0E;AAChF,IAAM,8CAAwE;AA+J9E,IAAM,iBAA2B;AAEjC,IAAM,cAAwB;AAC9B,IAAM,eAAyB;AAC/B,IAAM,kBAA4B;AAgGlC,IAAM,6BAAgD;AAItD,IAAM,+BAAkD;AAKxD,IAAM,4BAA+C;AAKrD,IAAM,2BAA8C;AAEpD,IAAM,2BAA+C;AACrD,IAAM,0BAA8C;AACpD,IAAM,yBAA6C;AA6BnD,IAAM,kBAAuC;AAa7C,IAAM,eAAsB;AAK5B,IAAM,gBAAuB;;;ADtmB7B,IAAM,eAAe,CAC1B,QACW;AACX,SAAO;AACT;",
  "names": []
}
