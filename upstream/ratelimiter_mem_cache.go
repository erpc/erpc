package upstream

import (
	"context"
	"math/rand"
	"sync"

	pb "github.com/envoyproxy/go-control-plane/envoy/service/ratelimit/v3"

	"github.com/envoyproxy/ratelimit/src/config"
	"github.com/envoyproxy/ratelimit/src/limiter"
	"github.com/envoyproxy/ratelimit/src/stats"
	"github.com/envoyproxy/ratelimit/src/utils"
)

// memoryRateLimitCache implements limiter.RateLimitCache using an in-process map.
// Keys include the time-sliced suffix generated by BaseRateLimiter, so we keep
// a simple TTL to avoid unbounded growth.
type memoryRateLimitCache struct {
	mu       sync.Mutex
	counters map[string]*memItem
	base     *limiter.BaseRateLimiter
	timeSrc  utils.TimeSource
}

type memItem struct {
	value  uint64
	expiry int64 // unix seconds
}

func NewMemoryRateLimitCache(
	timeSource utils.TimeSource,
	jitterRand *rand.Rand,
	expirationJitterMaxSeconds int64,
	nearLimitRatio float32,
	cacheKeyPrefix string,
	statsManager stats.Manager,
) limiter.RateLimitCache {
	return &memoryRateLimitCache{
		counters: make(map[string]*memItem, 1024),
		base:     limiter.NewBaseRateLimit(timeSource, jitterRand, expirationJitterMaxSeconds, nil, nearLimitRatio, cacheKeyPrefix, statsManager),
		timeSrc:  timeSource,
	}
}

func (m *memoryRateLimitCache) DoLimit(
	ctx context.Context,
	request *pb.RateLimitRequest,
	limits []*config.RateLimit,
) []*pb.RateLimitResponse_DescriptorStatus {
	hitsAddends := utils.GetHitsAddends(request)
	cacheKeys := m.base.GenerateCacheKeys(request, limits, hitsAddends)

	now := m.timeSrc.UnixNow()
	statuses := make([]*pb.RateLimitResponse_DescriptorStatus, len(request.Descriptors))

	m.mu.Lock()
	defer m.mu.Unlock()

	// Cleanup expired keys opportunistically
	for k, it := range m.counters {
		if it != nil && it.expiry > 0 && it.expiry <= now {
			delete(m.counters, k)
		}
	}

	for i, ck := range cacheKeys {
		if ck.Key == "" {
			// No limit for this descriptor
			statuses[i] = m.base.GetResponseDescriptorStatus("", limiter.NewRateLimitInfo(limits[i], 0, 0, 0, 0), false, hitsAddends[i])
			continue
		}

		var before uint64
		it := m.counters[ck.Key]
		if it != nil && (it.expiry == 0 || it.expiry > now) {
			before = it.value
		}

		after := before + hitsAddends[i]
		li := limiter.NewRateLimitInfo(limits[i], before, after, 0, 0)
		statuses[i] = m.base.GetResponseDescriptorStatus(ck.Key, li, false, hitsAddends[i])

		// Update counter and set expiry for the current window
		exp := utils.UnitToDivider(limits[i].Limit.Unit)
		expiry := (now/exp)*exp + exp // end of current window
		if it == nil {
			it = &memItem{}
			m.counters[ck.Key] = it
		}
		it.value = after
		it.expiry = expiry
	}

	return statuses
}

func (m *memoryRateLimitCache) Flush() {}
